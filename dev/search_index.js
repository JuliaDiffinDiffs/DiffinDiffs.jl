var documenterSearchIndex = {"docs":
[{"location":"lib/panel/#Panel-Operations","page":"Panel Operations","title":"Panel Operations","text":"","category":"section"},{"location":"lib/panel/","page":"Panel Operations","title":"Panel Operations","text":"Modules = [DiffinDiffsBase]\nPages = [\"src/operations.jl\", \"src/time.jl\"]","category":"page"},{"location":"lib/panel/#DiffinDiffsBase.PanelStructure","page":"Panel Operations","title":"DiffinDiffsBase.PanelStructure","text":"PanelStructure{R<:Signed, IP<:AbstractVector, TP<:AbstractVector}\n\nPanel data structure defined by unique combinations of unit ids and time periods. It contains the information required for certain operations such as lag and diff. See also setpanel.\n\nFields\n\nrefs::Vector{R}: reference values that allow obtaining time gaps by taking differences.\ninvrefs::Dict{R, Int}: inverse map from refs to indices.\nidpool::IP: unique unit ids.\ntimepool::TP: sorted unique time periods.\nlaginds::Dict{Int, Vector{Int}}: a map from lag distances to vectors of indices of lagged values.\n\n\n\n\n\n","category":"type"},{"location":"lib/panel/#Base.diff-Tuple{PanelStructure, AbstractArray}","page":"Panel Operations","title":"Base.diff","text":"diff(panel::PanelStructure, v::AbstractArray; kwargs...)\n\nReturn the differences of v within observations for each unit in panel. By default, it calculates the first differences. See also diff!.\n\nKeywords\n\norder::Integer=1: the order of differences to be taken.\nl::Integer=1: the time interval between each pair of observations.\ndefault=missing: default values for indices where the differences do not exist.\n\n\n\n\n\n","category":"method"},{"location":"lib/panel/#DiffinDiffsBase.aligntime-Tuple{AbstractArray, Union{ScaledArray{T, R, N, RA, P}, SubArray{<:Any, <:Any, <:ScaledArray{T, R, N, RA, P}}} where {T, R, N, RA, P}}","page":"Panel Operations","title":"DiffinDiffsBase.aligntime","text":"aligntime(col::AbstractArray, time::ScaledArrOrSub)\naligntime(col::AbstractArray, time::RotatingTimeArray)\naligntime(data, colname::Union{Symbol,Integer}, timename::Union{Symbol,Integer})\n\nConvert a column of time values col to a ScaledArray with a pool that has the same first element and step size as the pool from the ScaledArray time. If time is a RotatingTimeArray with the time field being a ScaledArray, the returned array is also a RotatingTimeArray with the time field being the converted ScaledArray. Alternative, the arrays may be specified with a Tables.jl-compatible data table and column indices colname and timename. See also settime.\n\nThis is useful for representing all discretized time periods with the same scale so that the underlying reference values returned by DataAPI.refarray can be directly comparable across the columns.\n\n\n\n\n\n","category":"method"},{"location":"lib/panel/#DiffinDiffsBase.cellrows-Tuple{VecColumnTable, IdDict}","page":"Panel Operations","title":"DiffinDiffsBase.cellrows","text":"cellrows(cols::VecColumnTable, refrows::IdDict)\n\nA utility function for processing the object refrows returned by findcell. Unique row values from cols corresponding to the keys in refrows are sorted lexicographically and stored as rows in a new VecColumnTable. Groups of row indices from the values of refrows are permuted to match the order of row values and collected in a Vector.\n\nReturns\n\ncells::VecColumnTable: unique row values from columns in cols.\nrows::Vector{Vector{Int}}: row indices for each combination.\n\n\n\n\n\n","category":"method"},{"location":"lib/panel/#DiffinDiffsBase.diff!-Tuple{AbstractArray, PanelStructure, AbstractArray}","page":"Panel Operations","title":"DiffinDiffsBase.diff!","text":"diff!(dest::AbstractArray, panel::PanelStructure, v::AbstractArray; kwargs...)\n\nTake the differences of v within observations for each unit in panel and store the result in dest. By default, it calculates the first differences. See also diff.\n\nKeywords\n\norder::Integer=1: the order of differences to be taken.\nl::Integer=1: the time interval between each pair of observations.\ndefault=missing: default values for indices where the differences do not exist.\n\n\n\n\n\n","category":"method"},{"location":"lib/panel/#DiffinDiffsBase.findcell-Tuple{VecColumnTable}","page":"Panel Operations","title":"DiffinDiffsBase.findcell","text":"findcell(cols::VecColumnTable)\nfindcell(names, data, esample=Colon())\n\nGroup the row indices of a collection of data columns so that the combination of row values from these columns are the same within each group.\n\nInstead of directly providing the relevant portions of columns as VecColumnTable`, one may specify thenamesof columns fromdataof anyTables.jl-compatible table type over selected rows indicated byesample. Note that unlessesamplecovers all rows ofdata, the row indices are those for the subsample selected based onesamplerather than those for the fulldata`.\n\nReturns\n\nIdDict{Tuple, Vector{Int}}: a map from unique row values to row indices.\n\n\n\n\n\n","category":"method"},{"location":"lib/panel/#DiffinDiffsBase.findlag!","page":"Panel Operations","title":"DiffinDiffsBase.findlag!","text":"findlag!(panel::PanelStructure, l::Integer=1)\n\nConstruct a vector of indices of the lth lagged values for all id-time combinations of panel and save the result in panel.laginds. If a lagged value does not exist, its index is filled with 0. See also ilag!.\n\n\n\n\n\n","category":"function"},{"location":"lib/panel/#DiffinDiffsBase.findlead!","page":"Panel Operations","title":"DiffinDiffsBase.findlead!","text":"findlead!(panel::PanelStructure, l::Integer=1)\n\nConstruct a vector of indices of the lth lead values for all id-time combinations of panel and save the result in panel.laginds. If a lead value does not exist, its index is filled with 0. See also ilead!.\n\n\n\n\n\n","category":"function"},{"location":"lib/panel/#DiffinDiffsBase.ilag!","page":"Panel Operations","title":"DiffinDiffsBase.ilag!","text":"ilag!(panel::PanelStructure, l::Integer=1)\n\nReturn a vector of indices of the lth lagged values for all id-time combinations of panel. The indices are retrieved from panel if they have been collected before. Otherwise, they are created by calling findlag!. See also ilead!.\n\n\n\n\n\n","category":"function"},{"location":"lib/panel/#DiffinDiffsBase.ilead!","page":"Panel Operations","title":"DiffinDiffsBase.ilead!","text":"ilead!(panel::PanelStructure, l::Integer=1)\n\nReturn a vector of indices of the lth lead values for all id-time combinations of panel. The indices are retrieved from panel if they have been collected before. Otherwise, they are created by calling findlead!. See also ilag!.\n\n\n\n\n\n","category":"function"},{"location":"lib/panel/#DiffinDiffsBase.setpanel-Tuple{AbstractArray, AbstractArray}","page":"Panel Operations","title":"DiffinDiffsBase.setpanel","text":"setpanel(data, idname, timename; step, reftype, rotation)\nsetpanel(id::AbstractArray, time::AbstractArray; step, reftype, rotation)\n\nDeclare a PanelStructure which is required for certain operations such as lag and diff. Unit IDs and time values can be provided either as a table containing the relevant columns or as arrays. timestep must be specified unless the time array is a ScaledArray that is returned by settime.\n\nArguments\n\ndata: a Tables.jl-compatible data table.\nidname::Union{Symbol,Integer}: the name of the column in data that contains unit IDs.\ntimename::Union{Symbol,Integer}: the name of the column in data that contains time values.\nid::AbstractArray: the array containing unit IDs (only needed for the alternative method).\ntime::AbstractArray: the array containing time values (only needed for the alternative method).\n\nKeywords\n\nstep=nothing: the length of each time interval; try step=one(eltype(time)) if not specified.\nreftype::Type{<:Signed}=Int32: the element type of the reference values for PanelStructure.\nrotation=nothing: rotation groups in a rotating sampling design; use RotatingTimeValues as reference values.\n\nnote: Note\nIf the underlying data used to create the PanelStructure are modified. The changes will not be reflected in the existing instances of PanelStructure. A new instance needs to be created with setpanel.\n\n\n\n\n\n","category":"method"},{"location":"lib/panel/#DiffinDiffsBase.settime","page":"Panel Operations","title":"DiffinDiffsBase.settime","text":"settime(time::AbstractArray, step; start, stop, reftype, rotation)\n\nConvert a column of time values to a ScaledArray for representing discretized time periods of uniform length. If rotation is specified (time values belong to multiple rotation groups), a RotatingTimeArray is returned with the time field being a ScaledArray. The returned array ensures well-defined time intervals for operations involving relative time (such as lag and diff). See also aligntime.\n\nArguments\n\ntime::AbstractArray: the array containing time values.\nstep=nothing: the length of each time interval; try step=one(eltype(time)) if not specified.\n\nKeywords\n\nstart=nothing: the first element of the pool of the returned ScaledArray.\nstop=nothing: the last element of the pool of the returned ScaledArray.\nreftype::Type{<:Signed}=Int32: the element type of the reference values for the ScaledArray.\nrotation=nothing: rotation groups in a rotating sampling design.\n\n\n\n\n\n","category":"function"},{"location":"lib/panel/#ShiftedArrays.lag","page":"Panel Operations","title":"ShiftedArrays.lag","text":"lag(panel::PanelStructure, v::AbstractArray, l::Integer=1; default=missing)\n\nReturn a vector of lth lagged values of v with missing values filled with default. The panel structure is respected. See also ilag! and lead.\n\n\n\n\n\n","category":"function"},{"location":"lib/panel/#ShiftedArrays.lead","page":"Panel Operations","title":"ShiftedArrays.lead","text":"lead(panel::PanelStructure, v::AbstractArray, l::Integer=1; default=missing)\n\nReturn a vector of lth lead values of v with missing values filled with default. The panel structure is respected. See also ilead! and lag.\n\n\n\n\n\n","category":"function"},{"location":"lib/panel/#DiffinDiffsBase.RotatingTimeArray","page":"Panel Operations","title":"DiffinDiffsBase.RotatingTimeArray","text":"RotatingTimeArray{T<:RotatingTimeValue,N,C,I} <: AbstractArray{T,N}\n\nArray type for RotatingTimeValues that stores the field values rotation and time in two arrays for efficiency. The two arrays that hold the field values for all elements can be accessed as properties.\n\n\n\n\n\n","category":"type"},{"location":"lib/panel/#DiffinDiffsBase.RotatingTimeArray-Tuple{AbstractArray, AbstractArray}","page":"Panel Operations","title":"DiffinDiffsBase.RotatingTimeArray","text":"RotatingTimeArray(rotation::AbstractArray, time::AbstractArray)\n\nConstruct a RotatingTimeValue from arrays of rotation and time.\n\n\n\n\n\n","category":"method"},{"location":"lib/panel/#DiffinDiffsBase.RotatingTimeValue","page":"Panel Operations","title":"DiffinDiffsBase.RotatingTimeValue","text":"RotatingTimeValue{R, T}\n\nA wrapper around a time value for distinguishing potentially different rotation group it could belong to in a rotating sampling design. See also rotatingtime and settime.\n\nFields\n\nrotation::R: a rotation group in a rotating sampling design.\ntime::T: a time value belonged to the rotation group.\n\n\n\n\n\n","category":"type"},{"location":"lib/panel/#DiffinDiffsBase.rotatingtime-Tuple{Any, Any}","page":"Panel Operations","title":"DiffinDiffsBase.rotatingtime","text":"rotatingtime(rotation, time)\n\nConstruct RotatingTimeValues from rotation and time. This method simply broadcasts the default constructor over the arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures","page":"StatsProcedures","title":"StatsProcedures","text":"","category":"section"},{"location":"lib/StatsProcedures/","page":"StatsProcedures","title":"StatsProcedures","text":"Modules = [StatsProcedures]","category":"page"},{"location":"lib/StatsProcedures/#StatsProcedures.AbstractStatsProcedure","page":"StatsProcedures","title":"StatsProcedures.AbstractStatsProcedure","text":"AbstractStatsProcedure{Alias, T<:NTuple{N,StatsStep} where N}\n\nSupertype for all types specifying the procedure for statistical estimation or inference.\n\nFallback methods for indexing and iteration are defined for all subtypes of AbstractStatsProcedure.\n\nParameters\n\nAlias::Symbol: alias of the type for pretty-printing.\nT<:NTuple{N,StatsStep}: steps involved in the procedure.\n\n\n\n\n\n","category":"type"},{"location":"lib/StatsProcedures/#StatsProcedures.PooledStatsProcedure","page":"StatsProcedures","title":"StatsProcedures.PooledStatsProcedure","text":"PooledStatsProcedure\n\nA collection of procedures and shared steps.\n\nAn instance of PooledStatsProcedure is indexed and iterable among the shared steps in a way that helps avoid repeating identical steps. See also pool.\n\nFields\n\nprocs::Vector{AbstractStatsProcedure}: a collection of AbstractStatsProcedures.\nsteps::Vector{SharedStatsStep}: sorted SharedStatsSteps.\n\n\n\n\n\n","category":"type"},{"location":"lib/StatsProcedures/#StatsProcedures.SharedStatsStep","page":"StatsProcedures","title":"StatsProcedures.SharedStatsStep","text":"SharedStatsStep\n\nA StatsStep that is possibly shared by multiple instances of procedures that are subtypes of AbstractStatsProcedure. See also PooledStatsProcedure.\n\nFields\n\nstep::StatsStep: the step that may be shared.\nids::Vector{Int}: indices of procedures that share step.\n\n\n\n\n\n","category":"type"},{"location":"lib/StatsProcedures/#StatsProcedures.StatsSpec","page":"StatsProcedures","title":"StatsProcedures.StatsSpec","text":"StatsSpec{T<:AbstractStatsProcedure}\n\nRecord the specification for a statistical procedure of type T.\n\nAn instance of StatsSpec is callable and its fields provide all information necessary for conducting the procedure. An optional name for the specification can be specified.\n\nFields\n\nname::String: a name for the specification (takes \"\" if not specified).\nargs::NamedTuple: arguments for the StatsSteps in T (default values are merged into args if not found in args).\n\nMethods\n\n(sp::StatsSpec{T})(; verbose::Bool=false, keep=nothing, keepall::Bool=false)\n\nExecute the procedure of type T with the arguments specified in args. By default, a dedicated result object for T is returned if it is available. Otherwise, the last value returned by the last StatsStep is returned.\n\nKeywords\n\nverbose::Bool=false: print the name of each step when it is called.\nkeep=nothing: names (of type Symbol) of additional objects to be returned.\nkeepall::Bool=false: return all objects returned by each step.\n\n\n\n\n\n","category":"type"},{"location":"lib/StatsProcedures/#StatsProcedures.StatsStep","page":"StatsProcedures","title":"StatsProcedures.StatsStep","text":"StatsStep{Alias, F<:Function, ById}\n\nSpecify the function for moving a step in an AbstractStatsProcedure. An instance of StatsStep is callable.\n\nParameters\n\nAlias::Symbol: alias of the type for pretty-printing.\nF<:Function: type of the function to be called by StatsStep.\nById::Bool: whether arguments from multiple StatsSpecs should be grouped by object-id or isequal.\n\nMethods\n\n(step::StatsStep{A,F})(ntargs::NamedTuple; verbose::Bool=false)\n\nCall an instance of function of type F with arguments extracted from ntargs via groupargs and combinedargs.\n\nA message with the name of the StatsStep is printed to stdout if a keyword verbose takes the value true or ntargs contains a key-value pair verbose=true. The value from ntargs supersedes the keyword argument in case both are specified.\n\nReturns\n\nNamedTuple: named intermediate results.\n\n\n\n\n\n","category":"type"},{"location":"lib/StatsProcedures/#Base.:==-Union{Tuple{T}, Tuple{StatsSpec{T}, StatsSpec{T}}} where T","page":"StatsProcedures","title":"Base.:==","text":"==(x::StatsSpec{T}, y::StatsSpec{T})\n\nTest whether two instances of StatsSpec with the same parameter T also have the same field args.\n\nSee also ≊.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures.:≊-Union{Tuple{T2}, Tuple{N2}, Tuple{T1}, Tuple{N1}, Tuple{NamedTuple{N1, T1}, NamedTuple{N2, T2}}} where {N1, T1, N2, T2}","page":"StatsProcedures","title":"StatsProcedures.:≊","text":"≊(x::NamedTuple, y::NamedTuple)\n\nTest whether two instances of NamedTuple contain the same set of key-value pairs while ignoring the order.\n\nSee https://discourse.julialang.org/t/check-equality-of-two-namedtuples-with-order-of-the-fields-ignored\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures.:≊-Union{Tuple{T}, Tuple{StatsSpec{T}, StatsSpec{T}}} where T","page":"StatsProcedures","title":"StatsProcedures.:≊","text":"≊(x::StatsSpec{T}, y::StatsSpec{T})\n\nTest whether two instances of StatsSpec with the same parameter T also have the field args containing the same sets of key-value pairs while ignoring the orders.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures._args_kwargs-Tuple{Any}","page":"StatsProcedures","title":"StatsProcedures._args_kwargs","text":"_args_kwargs(exprs)\n\nReturn an expression of Vector{Any} and an expression of Dict{Symbol,Any} where the latter collects any Expr in exprs with head being :(=) and the former collects the rest.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures.combinedargs-Tuple{StatsStep, Any}","page":"StatsProcedures","title":"StatsProcedures.combinedargs","text":"combinedargs(s::StatsStep, allntargs::Any)\n\nReturn a tuple of arguments obtained by combining a collection of arguments across multiple specifications.\n\nThe element type of allntargs can be assumed to be NamedTuple. This function allows combining arguments that differ across specifications in the same group classified based on groupargs into objects that are accepted by the call of s. See also proceed.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures.default-Tuple{StatsStep}","page":"StatsProcedures","title":"StatsProcedures.default","text":"default(s::StatsStep)\n\nReturn a NamedTuple of arguments with keys showing the names and values representing the defaults to be used to form groupargs. See also required and transformed.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures.groupargs-Tuple{StatsStep, NamedTuple}","page":"StatsProcedures","title":"StatsProcedures.groupargs","text":"groupargs(s::StatsStep, ntargs::NamedTuple)\n\nReturn a tuple of arguments that allow classifying multiple ntargss into groups. Equality (defined by isequal) of the returned tuples across ntargss imply that it is possible to exectute step s for only once to obtain results for these ntargss.\n\nThis function is important for proceed to work properly. However, in most cases, there is no need to define new methods for concrete StatsSteps. Instead, one should define methods for required, default or transformed. See also combinedargs.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures.pool-Tuple{Vararg{AbstractStatsProcedure}}","page":"StatsProcedures","title":"StatsProcedures.pool","text":"pool(ps::AbstractStatsProcedure...)\n\nConstruct a PooledStatsProcedure by determining how each StatsStep is shared among several procedures in ps.\n\nIt is unsafe to share the same StatsStep in different procedures due to the relative position of this step to the other common steps among these procedures. The fallback method implemented for a collection of AbstractStatsProcedure avoids sharing steps of which the relative positions are not compatible between a pair of procedures.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures.proceed-Tuple{Vector{<:StatsSpec}}","page":"StatsProcedures","title":"StatsProcedures.proceed","text":"proceed(sps::AbstractVector{<:StatsSpec}; kwargs...)\n\nCarry out the procedures for the StatsSpecs in sps while trying to avoid repeating identical steps for the StatsSpecs. See also @specset.\n\nKeywords\n\nverbose::Bool=false: print the name of each step when it is called.\nkeep=nothing: names (of type Symbol) of additional objects to be returned.\nkeepall::Bool=false: return all objects generated by procedures along with arguments from the StatsSpecs.\npause::Int=0: break the iteration over StatsSteps after finishing the specified number of steps (for debugging).\n\nReturns\n\nVector: results for each specification in the same order of sps.\n\nBy default, either a dedicated result object for the corresponding procedure or the last value returned by the last StatsStep becomes an element in the returned Vector for each StatsSpec. When either keep or keepall is specified, a NamedTuple with additional objects is formed for each StatsSpec.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures.required-Tuple{StatsStep}","page":"StatsProcedures","title":"StatsProcedures.required","text":"required(s::StatsStep)\n\nReturn a tuple of Symbols representing the names of arguments used to form groupargs that do not have defaults. See also default and transformed.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures.transformed-Tuple{StatsStep, NamedTuple}","page":"StatsProcedures","title":"StatsProcedures.transformed","text":"transformed(s::StatsStep, ntargs::NamedTuple)\n\nReturn a tuple of arguments transformed from fields in ntargs to be used to form groupargs. See also required and default.\n\n\n\n\n\n","category":"method"},{"location":"lib/StatsProcedures/#StatsProcedures.@specset-Tuple","page":"StatsProcedures","title":"StatsProcedures.@specset","text":"@specset [option option=val ...] default_args... begin ... end\n@specset [option option=val ...] default_args... for v in (...) ... end\n@specset [option option=val ...] default_args... for v in (...), w in (...) ... end\n\nConstruct a vector of StatsSpecs with shared default values for arguments and then conduct the procedures by calling proceed. The vector of StatsSpecs and a vector of result objects are returned, unless alternative behavior is specified with the options.\n\nArguments\n\n[option option=val ...]: optional settings for @specset including keyword arguments for proceed.\ndefault_args...: optional default values for arguments shared by all StatsSpecs.\ncode block: a begin/end block or a for loop containing arguments for constructing StatsSpecs.\n\nNotes\n\n@specset transforms Exprs that construct StatsSpec to collect the sets of arguments from the code block and infers how the arguments entered by users need to be processed based on the names of functions called within StatsSpec. For end users, Macros that generate Exprs for these function calls should be provided.\n\nOptional default arguments are merged with the arguments provided for each individual specification and supersede any default value associated with each StatsStep via default. These default arguments should be specified in the same pattern as how arguments are specified for each specification inside the code block, as @specset processes these arguments by calling the same functions found in the code block.\n\nOptions for the behavior of @specset can be provided in a bracket [...] as the first argument with each option separated by white space. For options that take a Boolean value, specifying the name of the option is enough for setting the value to be true.\n\nThe following options are available for altering the behavior of @specset:\n\nnoproceed::Bool=false: do not call proceed and only return the vector of StatsSpecs.\nverbose::Bool=false: print the name of each step when it is called.\nkeep=nothing: names (of type Symbol) of additional objects to be returned.\nkeepall::Bool=false: return all objects generated by procedures along with arguments from the StatsSpecs.\npause::Int=0: break the iteration over StatsSteps after finishing the specified number of steps (for debugging).\n\n\n\n\n\n","category":"macro"},{"location":"lib/procedures/#Procedures","page":"Procedures","title":"Procedures","text":"","category":"section"},{"location":"lib/procedures/","page":"Procedures","title":"Procedures","text":"Modules = [DiffinDiffsBase, InteractionWeightedDIDs]\nPages = [\"src/procedures.jl\"]","category":"page"},{"location":"lib/procedures/#DiffinDiffsBase.CheckData","page":"Procedures","title":"DiffinDiffsBase.CheckData","text":"CheckData <: StatsStep\n\nCall DiffinDiffsBase.checkdata! for some preliminary checks of the input data.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#DiffinDiffsBase.CheckVars","page":"Procedures","title":"DiffinDiffsBase.CheckVars","text":"CheckVars <: StatsStep\n\nCall DiffinDiffsBase.checkvars! to exclude invalid rows for relevant variables.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#DiffinDiffsBase.GroupContrasts","page":"Procedures","title":"DiffinDiffsBase.GroupContrasts","text":"GroupContrasts <: StatsStep\n\nCall DiffinDiffsBase.groupcontrasts to obtain one of the instances of contrasts that have been grouped by equality (hash) for allowing later comparisons based on object-id.\n\nThis step is only useful when working with @specset and proceed.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#DiffinDiffsBase.GroupSample","page":"Procedures","title":"DiffinDiffsBase.GroupSample","text":"GroupSample <: StatsStep\n\nCall DiffinDiffsBase.groupsample to obtain one of the instances of esample that have been grouped by equality (hash) for allowing later comparisons based on object-id.\n\nThis step is only useful when working with @specset and proceed.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#DiffinDiffsBase.GroupTreatintterms","page":"Procedures","title":"DiffinDiffsBase.GroupTreatintterms","text":"GroupTreatintterms <: StatsStep\n\nCall DiffinDiffsBase.grouptreatintterms to obtain one of the instances of treatintterms that have been grouped by equality (hash) for allowing later comparisons based on object-id.\n\nThis step is only useful when working with @specset and proceed.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#DiffinDiffsBase.GroupXterms","page":"Procedures","title":"DiffinDiffsBase.GroupXterms","text":"GroupXterms <: StatsStep\n\nCall DiffinDiffsBase.groupxterms to obtain one of the instances of xterms that have been grouped by equality (hash) for allowing later comparisons based on object-id.\n\nThis step is only useful when working with @specset and proceed.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#DiffinDiffsBase.MakeWeights","page":"Procedures","title":"DiffinDiffsBase.MakeWeights","text":"MakeWeights <: StatsStep\n\nCall DiffinDiffsBase.makeweights to create a generic Weights vector.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#DiffinDiffsBase.checkdata!-Tuple{Any, Union{Nothing, BitVector}, Union{Nothing, Symbol}}","page":"Procedures","title":"DiffinDiffsBase.checkdata!","text":"checkdata!(args...)\n\nCheck data is Tables.AbstractColumns-compatible and find valid rows for options subset and weightname. See also CheckData.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#DiffinDiffsBase.checkvars!-Tuple{Any, AbstractParallel, AbstractTerm, Symbol, BitVector, BitVector, TermSet, TermSet, Type, Tuple, AbstractTreatment}","page":"Procedures","title":"DiffinDiffsBase.checkvars!","text":"checkvars!(args...)\n\nExclude rows with missing data or violate the overlap condition and find rows with data from treated units. See also CheckVars.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#DiffinDiffsBase.groupcontrasts-Tuple{Union{Nothing, Dict{Symbol, Any}}}","page":"Procedures","title":"DiffinDiffsBase.groupcontrasts","text":"groupcontrasts(contrasts)\n\nReturn the argument without change for allowing later comparisons based on object-id. See also GroupContrasts.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#DiffinDiffsBase.groupsample-Tuple{BitVector}","page":"Procedures","title":"DiffinDiffsBase.groupsample","text":"groupsample(esample)\n\nReturn the argument without change for allowing later comparisons based on object-id. See also GroupSample.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#DiffinDiffsBase.grouptreatintterms-Tuple{TermSet}","page":"Procedures","title":"DiffinDiffsBase.grouptreatintterms","text":"grouptreatintterms(treatintterms)\n\nReturn the argument without change for allowing later comparisons based on object-id. See also GroupTreatintterms.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#DiffinDiffsBase.groupxterms-Tuple{TermSet}","page":"Procedures","title":"DiffinDiffsBase.groupxterms","text":"groupxterms(xterms)\n\nReturn the argument without change for allowing later comparisons based on object-id. See also GroupXterms.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#DiffinDiffsBase.makeweights-Tuple{Any, BitVector, Symbol}","page":"Procedures","title":"DiffinDiffsBase.makeweights","text":"makeweights(args...)\n\nConstruct a generic Weights vector. See also MakeWeights.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.CheckFEs","page":"Procedures","title":"InteractionWeightedDIDs.CheckFEs","text":"CheckFEs <: StatsStep\n\nCall InteractionWeightedDIDs.checkfes! to drop any singleton observation from fixed effects over the relevant subsample.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#InteractionWeightedDIDs.CheckVcov","page":"Procedures","title":"InteractionWeightedDIDs.CheckVcov","text":"CheckVcov <: StatsStep\n\nCall InteractionWeightedDIDs.checkvcov! to exclude rows that are invalid for variance-covariance estimator.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#InteractionWeightedDIDs.EstVcov","page":"Procedures","title":"InteractionWeightedDIDs.EstVcov","text":"EstVcov <: StatsStep\n\nCall InteractionWeightedDIDs.estvcov to estimate variance-covariance matrix and F-statistic.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#InteractionWeightedDIDs.GroupFEterms","page":"Procedures","title":"InteractionWeightedDIDs.GroupFEterms","text":"GroupFEterms <: StatsStep\n\nCall InteractionWeightedDIDs.groupfeterms to obtain one of the instances of feterms that have been grouped by equality (hash) for allowing later comparisons based on object-id.\n\nThis step is only useful when working with @specset and proceed.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#InteractionWeightedDIDs.MakeFESolver","page":"Procedures","title":"InteractionWeightedDIDs.MakeFESolver","text":"MakeFESolver <: StatsStep\n\nCall InteractionWeightedDIDs.makefesolver to construct the fixed effect solver.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#InteractionWeightedDIDs.MakeFEs","page":"Procedures","title":"InteractionWeightedDIDs.MakeFEs","text":"MakeFEs <: StatsStep\n\nCall InteractionWeightedDIDs.makefes to construct FixedEffects from data (the full sample).\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#InteractionWeightedDIDs.MakeTreatCols","page":"Procedures","title":"InteractionWeightedDIDs.MakeTreatCols","text":"MakeTreatCols <: StatsStep\n\nCall InteractionWeightedDIDs.maketreatcols to obtain residualized binary columns that capture treatment effects and obtain cell-level weight sums and observation counts.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#InteractionWeightedDIDs.MakeYXCols","page":"Procedures","title":"InteractionWeightedDIDs.MakeYXCols","text":"MakeYXCols <: StatsStep\n\nCall InteractionWeightedDIDs.makeyxcols to obtain residualized outcome variables and covariates.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#InteractionWeightedDIDs.SolveLeastSquares","page":"Procedures","title":"InteractionWeightedDIDs.SolveLeastSquares","text":"SolveLeastSquares <: StatsStep\n\nCall InteractionWeightedDIDs.solveleastsquares! to solve the least squares problem for regression coefficients and residuals.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#InteractionWeightedDIDs.SolveLeastSquaresWeights","page":"Procedures","title":"InteractionWeightedDIDs.SolveLeastSquaresWeights","text":"SolveLeastSquaresWeights <: StatsStep\n\nCall InteractionWeightedDIDs.solveleastsquaresweights to solve the cell-level weights assigned by least squares. If lswtnames is not specified, cells are defined by the partition based on treatment time and calendar time.\n\n\n\n\n\n","category":"type"},{"location":"lib/procedures/#InteractionWeightedDIDs.checkfes!-Tuple{Set{Pair{Vector{Symbol}, Vector{Symbol}}}, Dict{Pair{Vector{Symbol}, Vector{Symbol}}, FixedEffects.FixedEffect}, BitVector, Bool}","page":"Procedures","title":"InteractionWeightedDIDs.checkfes!","text":"checkfes!(args...)\n\nDrop any singleton observation from fixed effects over the relevant subsample. See also CheckFEs.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.checkvcov!-Tuple{Any, BitVector, BitVector, Union{Vcov.RobustCovariance, Vcov.SimpleCovariance}}","page":"Procedures","title":"InteractionWeightedDIDs.checkvcov!","text":"checkvcov!(args...)\n\nExclude rows that are invalid for variance-covariance estimator. See also CheckVcov.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.estvcov-Tuple{Any, BitVector, StatsBase.CovarianceEstimator, Vector, Matrix, LinearAlgebra.Factorization, Vector, Vector{AbstractTerm}, Vector{FixedEffects.FixedEffect}, Bool}","page":"Procedures","title":"InteractionWeightedDIDs.estvcov","text":"estvcov(args...)\n\nEstimate variance-covariance matrix and F-statistic. See also EstVcov.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.groupfeterms-Tuple{Set{Pair{Vector{Symbol}, Vector{Symbol}}}}","page":"Procedures","title":"InteractionWeightedDIDs.groupfeterms","text":"groupfeterms(feterms)\n\nReturn the argument without change for allowing later comparisons based on object-id. See also GroupFEterms.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.makefes-Tuple{Any, Vector{Pair{Vector{Symbol}, Vector{Symbol}}}}","page":"Procedures","title":"InteractionWeightedDIDs.makefes","text":"makefes(args...)\n\nConstruct FixedEffects from data (the full sample). See also MakeFEs.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.makefesolver-Tuple{Vector{FixedEffects.FixedEffect}, StatsBase.AbstractWeights, Int64}","page":"Procedures","title":"InteractionWeightedDIDs.makefesolver","text":"makefesolver(args...)\n\nConstruct FixedEffects.AbstractFixedEffectSolver. See also MakeFESolver.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.maketreatcols-Tuple{Any, Symbol, TermSet, Union{Nothing, FixedEffects.AbstractFixedEffectSolver}, StatsBase.AbstractWeights, BitVector, Bool, Real, Int64, Symbol, Dict{Int64, Int64}, IdDict{Union{Signed, Dates.Period, Dates.TimeType, RotatingTimeValue}, Int64}}","page":"Procedures","title":"InteractionWeightedDIDs.maketreatcols","text":"maketreatcols(args...)\n\nConstruct residualized binary columns that capture treatment effects and obtain cell-level weight sums and observation counts. See also MakeTreatCols.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.makeyxcols-Tuple{Any, StatsBase.AbstractWeights, BitVector, Union{Nothing, FixedEffects.AbstractFixedEffectSolver}, Bool, Union{Nothing, Dict}, Real, Int64, TermSet}","page":"Procedures","title":"InteractionWeightedDIDs.makeyxcols","text":"makeyxcols(args...)\n\nConstruct columns for outcome variables and covariates and residualize them with fixed effects. See also MakeYXCols.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.parsefeterms!-Tuple{TermSet}","page":"Procedures","title":"InteractionWeightedDIDs.parsefeterms!","text":"parsefeterms!(xterms)\n\nExtract any FixedEffectTerm or interaction of FixedEffectTerm from xterms and determine whether any intercept term should be omitted. See also ParseFEterms.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.solveleastsquares!-Tuple{DynamicTreatment{SharpDesign}, TrendOrUnspecifiedPR, AbstractTerm, TermSet, Dict, Dict, VecColumnTable, Vector, Vector, Vector, Bool, Bool}","page":"Procedures","title":"InteractionWeightedDIDs.solveleastsquares!","text":"solveleastsquares!(args...)\n\nSolve the least squares problem for regression coefficients and residuals. See also SolveLeastSquares.\n\n\n\n\n\n","category":"method"},{"location":"lib/procedures/#InteractionWeightedDIDs.solveleastsquaresweights-Tuple{DynamicTreatment{SharpDesign}, Bool, Any, VecColumnTable, Vector{Vector{Int64}}, Matrix, LinearAlgebra.Factorization, Vector, VecColumnTable, AbstractTerm, Vector{AbstractTerm}, Dict, Dict, Union{Nothing, FixedEffects.AbstractFixedEffectSolver}, Real, Int64, StatsBase.AbstractWeights}","page":"Procedures","title":"InteractionWeightedDIDs.solveleastsquaresweights","text":"solveleastsquaresweights(args...)\n\nSolve the cell-level weights assigned by least squares. If lswtnames is not specified, cells are defined by the partition based on treatment time and calendar time. See also SolveLeastSquaresWeights.\n\n\n\n\n\n","category":"method"},{"location":"lib/estimators/#Estimators","page":"Estimators","title":"Estimators","text":"","category":"section"},{"location":"lib/estimators/","page":"Estimators","title":"Estimators","text":"Modules = [DiffinDiffsBase, InteractionWeightedDIDs]\nFilter = t -> typeof(t) === DataType && t <: DiffinDiffsEstimator","category":"page"},{"location":"lib/estimators/#DiffinDiffsBase.DefaultDID","page":"Estimators","title":"DiffinDiffsBase.DefaultDID","text":"DefaultDID <: DiffinDiffsEstimator\n\nDefault difference-in-differences estimator selected based on the context.\n\n\n\n\n\n","category":"type"},{"location":"lib/estimators/#InteractionWeightedDIDs.Reg","page":"Estimators","title":"InteractionWeightedDIDs.Reg","text":"Reg <: DiffinDiffsEstimator\n\nAlias for RegressionBasedDID.\n\n\n\n\n\n","category":"type"},{"location":"lib/estimators/#InteractionWeightedDIDs.RegressionBasedDID","page":"Estimators","title":"InteractionWeightedDIDs.RegressionBasedDID","text":"RegressionBasedDID <: DiffinDiffsEstimator\n\nEstimation procedure for regression-based difference-in-differences.\n\nA StatsSpec for this procedure accepts the following arguments:\n\nKey Type restriction Default value Description\ndata   A Tables.jl-compatible data table\ntr DynamicTreatment{SharpDesign}  Treatment specification\npr TrendOrUnspecifiedPR{Unconditional,Exact}  Parallel trend assumption\nyterm AbstractTerm  A term for outcome variable\ntreatname Symbol  Column name for the variable representing treatment time\nsubset Union{BitVector,Nothing} nothing Rows from data to be used for estimation\nweightname Union{Symbol,Nothing} nothing Column name of the sample weight variable\nvce Vcov.CovarianceEstimator Vcov.CovarianceEstimator Variance-covariance estimator\ntreatintterms TermSet TermSet() Terms interacted with the treatment indicators\nxterms TermSet TermSet() Terms for covariates and fixed effects\ncontrasts Union{Dict{Symbol,Any},Nothing} nothing Contrast coding to be processed by StatsModels.jl\ndrop_singletons Bool true Drop singleton observations for fixed effects\nnfethreads Int Threads.nthreads() Number of threads to be used for solving fixed effects\nfetol Float64 1e-8 Tolerance level for the fixed effect solver\nfemaxiter Int 10000 Maximum number of iterations allowed for the fixed effect solver\ncohortinteracted Bool true Interact treatment indicators by treatment time\nsolvelsweights Bool false Solve the cell-level least-square weights with default cell partition\nlswtnames Iterable of Symbols tuple() Column names from treatcells defining the cell partition used for solving least-square weights\n\n\n\n\n\n","category":"type"},{"location":"lib/treatments/#Treatment-Types","page":"Treatment Types","title":"Treatment Types","text":"","category":"section"},{"location":"lib/treatments/","page":"Treatment Types","title":"Treatment Types","text":"Modules = [DiffinDiffsBase]\nPages = [\"src/treatments.jl\"]","category":"page"},{"location":"lib/treatments/#DiffinDiffsBase.AbstractTreatment","page":"Treatment Types","title":"DiffinDiffsBase.AbstractTreatment","text":"AbstractTreatment\n\nSupertype for all treatment types.\n\n\n\n\n\n","category":"type"},{"location":"lib/treatments/#DiffinDiffsBase.DynamicTreatment","page":"Treatment Types","title":"DiffinDiffsBase.DynamicTreatment","text":"DynamicTreatment{S<:TreatmentSharpness} <: AbstractTreatment\n\nSpecify an absorbing binary treatment with effects allowed to evolve over time. See also dynamic.\n\nFields\n\ntime::Symbol: column name of data representing calendar time.\nexc::Tuple{Vararg{Int}}: excluded relative time.\ns::S: an instance of TreatmentSharpness.\n\n\n\n\n\n","category":"type"},{"location":"lib/treatments/#DiffinDiffsBase.SharpDesign","page":"Treatment Types","title":"DiffinDiffsBase.SharpDesign","text":"SharpDesign <: TreatmentSharpness\n\nAssume identical treatment within each treatment group.\n\n\n\n\n\n","category":"type"},{"location":"lib/treatments/#DiffinDiffsBase.TreatmentSharpness","page":"Treatment Types","title":"DiffinDiffsBase.TreatmentSharpness","text":"TreatmentSharpness\n\nSupertype for all types specifying the sharpness of treatment.\n\n\n\n\n\n","category":"type"},{"location":"lib/treatments/#DiffinDiffsBase.dynamic","page":"Treatment Types","title":"DiffinDiffsBase.dynamic","text":"dynamic(time::Symbol, exc, s::TreatmentSharpness=sharp())\n\nConstruct a DynamicTreatment with fields set by the arguments. By default, s is set as SharpDesign. When working with @formula, a wrapper method of dynamic calls this method.\n\nExamples\n\njulia> dynamic(:month, -1)\nSharp dynamic treatment:\n  column name of time variable: month\n  excluded relative time: -1\n\njulia> typeof(dynamic(:month, -1))\nDynamicTreatment{SharpDesign}\n\njulia> dynamic(:month, -3:-1)\nSharp dynamic treatment:\n  column name of time variable: month\n  excluded relative time: -3, -2, -1\n\njulia> dynamic(:month, [-2,-1], sharp())\nSharp dynamic treatment:\n  column name of time variable: month\n  excluded relative time: -2, -1\n\n\n\n\n\n","category":"function"},{"location":"lib/treatments/#DiffinDiffsBase.dynamic-Tuple{Vararg{AbstractTerm}}","page":"Treatment Types","title":"DiffinDiffsBase.dynamic","text":"dynamic(ts::AbstractTerm...)\n\nA wrapper method of dynamic for working with @formula.\n\n\n\n\n\n","category":"method"},{"location":"lib/treatments/#DiffinDiffsBase.sharp-Tuple{}","page":"Treatment Types","title":"DiffinDiffsBase.sharp","text":"sharp()\n\nAlias for SharpDesign().\n\n\n\n\n\n","category":"method"},{"location":"about/license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"about/license/","page":"License","title":"License","text":"DiffinDiffs.jl is licensed under the MIT license.","category":"page"},{"location":"lib/tables/#Tables","page":"Tables","title":"Tables","text":"","category":"section"},{"location":"lib/tables/","page":"Tables","title":"Tables","text":"Modules = [DiffinDiffsBase]\nPages = [\"src/tables.jl\"]","category":"page"},{"location":"lib/tables/#DiffinDiffsBase.TableIndexedMatrix","page":"Tables","title":"DiffinDiffsBase.TableIndexedMatrix","text":"TableIndexedMatrix{T,M,R,C} <: AbstractMatrix{T}\n\nMatrix with row and column indices that can be selected based on row values in a Tables.jl-compatible table respectively. This is useful when how elements are stored into the matrix are determined by the rows of the tables.\n\nParameters\n\nT: element type of the matrix.\nM: type of the matrix.\nR: type of the table paired with the row indices.\nC: type of the table paired with the column indices.\n\nFields\n\nm::M: the matrix that stores the elements.\nr::R: a table with the same number of rows with m.\nc::C: a table of which the number of rows is equal to the number of columns of m.\n\n\n\n\n\n","category":"type"},{"location":"lib/tables/#DiffinDiffsBase.VecColumnTable","page":"Tables","title":"DiffinDiffsBase.VecColumnTable","text":"VecColumnTable <: AbstractColumns\n\nA Tables.jl-compatible column table that stores data as Vector{AbstractVector} and column names as Vector{Symbol}. Retrieving columns by column names is achieved with a Dict{Symbol,Int} that maps names to indices.\n\nThis table type is designed for retrieving and iterating dynamically generated columns for which specialization on names and order of columns are not desired. It is not intended to be directly constructed for interactive usage.\n\n\n\n\n\n","category":"type"},{"location":"lib/tables/#DiffinDiffsBase.apply-Tuple{Any, Pair{Symbol, <:Function}}","page":"Tables","title":"DiffinDiffsBase.apply","text":"apply(d, by::Pair)\n\nApply a function elementwise to the specified column(s) in a Tables.jl-compatible table d and return the result.\n\nDepending on the argument(s) accepted by a function f, it is specified with argument by as either column_index => f or column_indices => f where column_index is either a Symbol or Int for a column in d and column_indices is an iterable collection of such indices for multiple columns. f is applied elementwise to each specified column to obtain an array of returned values.\n\n\n\n\n\n","category":"method"},{"location":"lib/tables/#DiffinDiffsBase.apply_and!-Tuple{BitVector, Any, Pair{Symbol, <:Function}}","page":"Tables","title":"DiffinDiffsBase.apply_and!","text":"apply_and!(inds::BitVector, d, by::Pair)\napply_and!(inds::BitVector, d, bys::Pair...)\n\nApply a function that returns true or false elementwise to the specified column(s) in a Tables.jl-compatible table d and then update the elements in inds through bitwise and with the returned array. If an array instead of a function is provided, elementwise equality (==) comparison is applied between the column and the array. See also apply_and.\n\nThe way a function is specified is the same as how it is done with apply. If multiple Pairs are provided, inds are updated for each returned array through bitwise and.\n\n\n\n\n\n","category":"method"},{"location":"lib/tables/#DiffinDiffsBase.apply_and-Tuple{Any, Pair{Symbol}}","page":"Tables","title":"DiffinDiffsBase.apply_and","text":"apply_and(d, by::Pair)\napply_and(d, bys::Pair...)\n\nApply a function that returns true or false elementwise to the specified column(s) in a Tables.jl-compatible table d and return the result. If an array instead of a function is provided, elementwise equality (==) comparison is applied between the column and the array. See also apply_and!.\n\nThe way a function is specified is the same as how it is done with apply. If multiple Pairs are provided, the returned array is obtained by combining arrays returned by each function through bitwise and.\n\n\n\n\n\n","category":"method"},{"location":"lib/tables/#DiffinDiffsBase.subcolumns","page":"Tables","title":"DiffinDiffsBase.subcolumns","text":"subcolumns(data, names, rows=Colon(); nomissing=true)\n\nConstruct a VecColumnTable from data using columns specified with names over selected rows.\n\nBy default, columns are converted to drop support for missing values. When possible, resulting columns share memory with original columns.\n\n\n\n\n\n","category":"function"},{"location":"man/getting-started/#Getting-Started","page":"Getting Started","title":"Getting Started","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"To demonstrate the basic usage of DiffinDiffs.jl, we walk through the processes of reproducing empirical results from relevant studies. Please refer to the original papers for details on the context.","category":"page"},{"location":"man/getting-started/#Dynamic-Effects-in-Event-Studies","page":"Getting Started","title":"Dynamic Effects in Event Studies","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"As a starting point, we reproduce results from the empirical illustration in Liyang Sun, Sarah Abraham (2021).","category":"page"},{"location":"man/getting-started/#Data-Preparation","page":"Getting Started","title":"Data Preparation","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"DiffinDiffs.jl requires that the data used for estimation are stored in a column table compatible with the interface defined in Tables.jl. This means that virtually all types of data frames, including DataFrames.jl, are supported. For the sake of illustration, here we directly load the dataset that is bundled with the package by calling exampledata:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"using DiffinDiffs\nhrs = exampledata(\"hrs\")","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"In this example, hhidpn, wave, and wave_hosp are columns for the unit IDs, time IDs and treatment time respectively. The rest of the columns contain the outcome variables and covariates. It is important that the time IDs and treatment time refer to each time period in a compatible way so that subtracting a value of treatment time from a value of calendar time (represented by a time ID) with operator - yields a meaningful value of relative time, the amount of time elapsed since treatment time.","category":"page"},{"location":"man/getting-started/#Empirical-Specifications","page":"Getting Started","title":"Empirical Specifications","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"To produce the estimates reported in panel (a) of Table 3 from Liyang Sun, Sarah Abraham (2021), we specify the estimation via @did as follows:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"r = @did(Reg, data=hrs, dynamic(:wave, -1), notyettreated(11),\n    vce=Vcov.cluster(:hhidpn), yterm=term(:oop_spend), treatname=:wave_hosp,\n    treatintterms=(), xterms=(fe(:wave)+fe(:hhidpn)))\nnothing # hide","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Before we look at the results, we briefly explain some of the arguments that are relatively more important. Reg, which is a shorthand for RegressionBasedDID, is the type of the estimation to be conducted. Here, we need estimation that is conducted by directly solving least-squares regression and hence we use Reg to inform @did the relevant set of procedures, which also determines the set of arguments that are accepted by @did.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"We are interested in the dynamic treatment effects. Hence, we use dynamic to specify the data column containing values representing calendar time of the observations and the reference period, which is -1. For identification, a crucial assumption underlying DID is the parallel trends assumption. Here, we assume that the average outcome paths of units treated in periods before 11 would be parallel to the observed paths of units treated in period 11. That is, we are taking units with treatment time 11 as the not-yet-treated control group. We specify treatname to be :wave_hosp, which indicates the column that contains the treatment time. The interpretation of treatname depends on the context that is jointly determined by the type of the estimator, the type of the treatment and possibly the type of parallel trends assumption. The rest of the arguments provide additional information on the regression specifications. The use of them can be found in the documentation for RegressionBasedDID.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"We now move on to the result returned by @did:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"r # hide","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"The object returned is of type RegressionBasedDIDResult, which contains the estimates for treatment-group-specific average treatment effects among other information. Instead of printing the estimates from the regression, which can be very long if there are many treatment groups, REPL prints a summary table for r. Here we verify that the estimate for relative time 0 among the cohort who received treatment in period 8 is about 2826, the value reported in the third column of Table 3(a) in the paper.","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"coef(r, \"wave_hosp: 8 & rel: 0\")","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Various accessor methods are defined for retrieving values from a result such as r. See Results for a full list of them.","category":"page"},{"location":"man/getting-started/#Aggregation-of-Estimates","page":"Getting Started","title":"Aggregation of Estimates","text":"","category":"section"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"The treatment-group-specific estimates in r are typically not the ultimate objects of interest. We need to estimate the path of the average dynamic treatment effects across all treatment groups. Such estimates can be easily obtained by aggregating the estimates in r via agg:","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"a = agg(r, :rel)","category":"page"},{"location":"man/getting-started/","page":"Getting Started","title":"Getting Started","text":"Notice that :rel is a special value used to indicate that the aggregation is conducted for each value of relative time separately. The aggregation takes into account sample weights of each treatment group and the variance-covariance matrix. The resulting estimates match those reported in the second column of Table 3(a) exactly.","category":"page"},{"location":"about/references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"about/references/","page":"References","title":"References","text":"","category":"page"},{"location":"lib/miscellanea/#Miscellanea","page":"Miscellanea","title":"Miscellanea","text":"","category":"section"},{"location":"lib/miscellanea/","page":"Miscellanea","title":"Miscellanea","text":"Modules = [DiffinDiffsBase, InteractionWeightedDIDs]\nPages = [\"src/utils.jl\"]","category":"page"},{"location":"lib/miscellanea/#DiffinDiffsBase.cb-Tuple","page":"Miscellanea","title":"DiffinDiffsBase.cb","text":"cb(args...)\n\nConstruct a vector from ConstantTerms provided as arguments. This method is useful for working with @formula.\n\nNote that @formula does not accept function calls with empty argument. Hence, cb() cannot be used to create an empty vector [] in the expression passed to @formula. However, passing cb (without the parenthesis) to @formula will return [] due to unpack.\n\n\n\n\n\n","category":"method"},{"location":"lib/miscellanea/#DiffinDiffsBase.exampledata-Tuple{Union{String, Symbol}}","page":"Miscellanea","title":"DiffinDiffsBase.exampledata","text":"exampledata(name::Union{Symbol,String})\n\nReturn a CSV.File containing the example dataset with the specified name.\n\n\n\n\n\n","category":"method"},{"location":"lib/miscellanea/#DiffinDiffsBase.exampledata-Tuple{}","page":"Miscellanea","title":"DiffinDiffsBase.exampledata","text":"exampledata()\n\nReturn the names of available example datasets.\n\n\n\n\n\n","category":"method"},{"location":"lib/miscellanea/#DiffinDiffsBase.kwarg-Tuple{Any}","page":"Miscellanea","title":"DiffinDiffsBase.kwarg","text":"kwarg(v)\n\nReturn a key-value Pair with the key being a keyword argument name and the value being v. The key is determined by the type of v.\n\n\n\n\n\n","category":"method"},{"location":"lib/miscellanea/#DiffinDiffsBase.unpack-Tuple{ConstantTerm}","page":"Miscellanea","title":"DiffinDiffsBase.unpack","text":"unpack(t::ConstantTerm)\n\nReturn the value represented by t.\n\n\n\n\n\n","category":"method"},{"location":"lib/miscellanea/#DiffinDiffsBase.unpack-Tuple{Term}","page":"Miscellanea","title":"DiffinDiffsBase.unpack","text":"unpack(t::Term)\n\nIf t.sym is the name of an object defined in Main, either call its method with no argument if it exists or return the object itself. Otherwise, return t.sym.\n\n\n\n\n\n","category":"method"},{"location":"lib/miscellanea/#DiffinDiffsBase.unpack-Union{Tuple{FunctionTerm{F}}, Tuple{F}} where F","page":"Miscellanea","title":"DiffinDiffsBase.unpack","text":"unpack(t::FunctionTerm{F})\n\nCall the function represented by t.\n\n\n\n\n\n","category":"method"},{"location":"lib/miscellanea/#DiffinDiffsBase.@fieldequal-Tuple{Any}","page":"Miscellanea","title":"DiffinDiffsBase.@fieldequal","text":"@fieldequal Supertype\n\nDefine a method of == for all subtypes of Supertype such that == returns true if two instances have the same field values.\n\n\n\n\n\n","category":"macro"},{"location":"lib/miscellanea/#DiffinDiffsBase.@unpack-Tuple{Any}","page":"Miscellanea","title":"DiffinDiffsBase.@unpack","text":"@unpack functionname\n\nDefine a method of functionname that accepts terms generated by @formula as arguments. This method can be used to translate terms into arguments that match the other methods of functionname. Each term is processed by unpack and kwarg.\n\n\n\n\n\n","category":"macro"},{"location":"lib/terms/#Treatment-Terms","page":"Formula Terms","title":"Treatment Terms","text":"","category":"section"},{"location":"lib/terms/","page":"Formula Terms","title":"Formula Terms","text":"Modules = [DiffinDiffsBase]\nPages = [\"src/terms.jl\"]","category":"page"},{"location":"lib/terms/#DiffinDiffsBase.TermSet","page":"Formula Terms","title":"DiffinDiffsBase.TermSet","text":"TermSet <: AbstractSet{AbstractTerm}\n\nWrapped Set{AbstractTerm} that specifies a collection of terms. Commonly used methods for Set work in the same way for TermSet.\n\nCompared with StatsModels.TermOrTerms, it does not maintain order of terms but is more suitable for dynamically constructed terms.\n\n\n\n\n\n","category":"type"},{"location":"lib/terms/#DiffinDiffsBase.TermSet-Tuple{}","page":"Formula Terms","title":"DiffinDiffsBase.TermSet","text":"TermSet([itr])\nTermSet(ts::Union{Int, Symbol, AbstractTerm}...)\n\nConstruct a TermSet from a collection of terms. Instead of passing an iterable collection, one may pass the terms as arguments directly. In the latter case, any Int or Symbol will be converted to a Term. See also termset, which is an alias for the constructor.\n\n\n\n\n\n","category":"method"},{"location":"lib/terms/#DiffinDiffsBase.TreatmentTerm","page":"Formula Terms","title":"DiffinDiffsBase.TreatmentTerm","text":"TreatmentTerm{T<:AbstractTreatment} <: AbstractTerm\n\nA term that contains specifications on treatment and parallel trends assumption. See also treat.\n\nFields\n\nsym::Symbol: the column name of data representing treatment status.\ntr::T: a treatment type that specifies the causal parameters of interest.\npr::P: a parallel type that specifies the parallel trends assumption.\n\n\n\n\n\n","category":"type"},{"location":"lib/terms/#DiffinDiffsBase.eachterm-Tuple{AbstractTerm}","page":"Formula Terms","title":"DiffinDiffsBase.eachterm","text":"eachterm(t)\n\nReturn an iterable collection of terms in t.\n\n\n\n\n\n","category":"method"},{"location":"lib/terms/#DiffinDiffsBase.hastreat-Tuple{TreatmentTerm}","page":"Formula Terms","title":"DiffinDiffsBase.hastreat","text":"hastreat(t)\n\nDetermine whether the term t contains an instance of TreatmentTerm.\n\n\n\n\n\n","category":"method"},{"location":"lib/terms/#DiffinDiffsBase.parse_intercept!-Tuple{TermSet}","page":"Formula Terms","title":"DiffinDiffsBase.parse_intercept!","text":"parse_intercept(ts::TermSet)\n\nRemove any ConstantTerm or InterceptTerm and return Boolean values indicating whether terms explictly requiring including/excluding the intercept exist.\n\nThis function is useful for obtaining a unique way of specifying the intercept before going through the schema–apply_schema pipeline defined in StatsModels.\n\n\n\n\n\n","category":"method"},{"location":"lib/terms/#DiffinDiffsBase.parse_treat-Tuple{FormulaTerm}","page":"Formula Terms","title":"DiffinDiffsBase.parse_treat","text":"parse_treat(formula::FormulaTerm)\n\nExtract terms related to treatment specifications from formula.\n\nReturns\n\nTreatmentTerm: the unique TreatmentTerm contained in the formula.\nTermSet: a set of terms that are interacted with the TreatmentTerm.\nTermSet: a set of remaining terms in formula.rhs.\n\nError will be raised if either existence or uniqueness of the TreatmentTerm is violated.\n\n\n\n\n\n","category":"method"},{"location":"lib/terms/#DiffinDiffsBase.termset-Tuple{}","page":"Formula Terms","title":"DiffinDiffsBase.termset","text":"termset([itr])\ntermset(ts::Union{Int, Symbol, AbstractTerm}...)\n\nConstruct a TermSet from a collection of terms. Instead of passing an iterable collection, one may pass the terms as arguments directly. In the latter case, any Int or Symbol will be converted to a Term.\n\n\n\n\n\n","category":"method"},{"location":"lib/terms/#DiffinDiffsBase.treat-Tuple{Symbol, AbstractTreatment, AbstractParallel}","page":"Formula Terms","title":"DiffinDiffsBase.treat","text":"treat(s::Symbol, t::AbstractTreatment, p::AbstractParallel)\n\nConstruct a TreatmentTerm with fields set by the arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/terms/#DiffinDiffsBase.treat-Union{Tuple{FP}, Tuple{FT}, Tuple{Term, FunctionTerm{FT}, FunctionTerm{FP}}} where {FT, FP}","page":"Formula Terms","title":"DiffinDiffsBase.treat","text":"treat(s::Term, t::FunctionTerm{FT}, p::FunctionTerm{FP})\n\nConstruct a TreatmentTerm with fields set by s.sym, FT.instance(t.args_parsed...) and FP.instance(p.args_parsed...). This method is called by parse_treat(formula) when the formula is constructed by @formula.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#Results","page":"Results","title":"Results","text":"","category":"section"},{"location":"lib/results/","page":"Results","title":"Results","text":"Modules = [DiffinDiffsBase, InteractionWeightedDIDs]\nPages = [\"src/did.jl\"]\nFilter = t -> !(typeof(t) === DataType && t <: DiffinDiffsEstimator)","category":"page"},{"location":"lib/results/#DiffinDiffsBase.AbstractDIDResult","page":"Results","title":"DiffinDiffsBase.AbstractDIDResult","text":"AbstractDIDResult{TR<:AbstractTreatment} <: StatisticalModel\n\nInterface supertype for all types that collect estimation results for difference-in-differences with treatment of type TR.\n\nInterface definition\n\nRequired method Default definition Brief description\ncoef(r) r.coef Vector of point estimates for all coefficients including covariates\nvcov(r) r.vcov Variance-covariance matrix for estimates in coef\nvce(r) r.vce Covariance estimator\nconfint(r) Based on t or normal distribution Confidence interval for estimates in coef\ntreatment(r) r.tr Treatment specification\nnobs(r) r.nobs Number of observations (table rows) involved in estimation\noutcomename(r) r.yname Name of the outcome variable\ncoefnames(r) r.coefnames Names (Vector{String}) of all coefficients including covariates\ntreatcells(r) r.treatcells Tables.jl-compatible tabular description of treatment coefficients in the order of coefnames (without covariates)\nweights(r) r.weights Name of the column containing sample weights (if specified)\nntreatcoef(r) size(treatcells(r), 1) Number of treatment coefficients\ntreatcoef(r) view(coef(r), 1:ntreatcoef(r)) A view of treatment coefficients\ntreatvcov(r) (N = ntreatcoef(r); view(vcov(r), 1:N, 1:N)) A view of variance-covariance matrix for treatment coefficients\ntreatnames(r) coefnames(r)[1:ntreatcoef(r)] Names (Vector{String}) of treatment coefficients\nOptional methods  \nparent(r) r.parent or r Result object from which r is generated\ndof_residual(r) r.dof_residual or nothing Residual degrees of freedom\nresponsename(r) outcomename(r) Name of the outcome variable\ncoefinds(r) r.coefinds or nothing Lookup table (Dict{String,Int}) from coefnames to integer indices (for retrieving estimates by name)\nncovariate(r) length(coef(r)) - ntreatcoef(r) Number of covariate coefficients\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#DiffinDiffsBase.AggregatedDIDResult","page":"Results","title":"DiffinDiffsBase.AggregatedDIDResult","text":"AggregatedDIDResult{TR,P<:DIDResult} <: AbstractDIDResult{TR}\n\nSupertype for all types that collect estimation results aggregated from a DIDResult of type P with treatment of type TR.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#DiffinDiffsBase.DIDResult","page":"Results","title":"DiffinDiffsBase.DIDResult","text":"DIDResult{TR} <: AbstractDIDResult{TR}\n\nSupertype for all types that collect estimation results directly obtained from DiffinDiffsEstimator with treatment of type TR.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#DiffinDiffsBase.DiffinDiffsEstimator","page":"Results","title":"DiffinDiffsBase.DiffinDiffsEstimator","text":"DiffinDiffsEstimator{A,T} <: AbstractStatsProcedure{A,T}\n\nSpecify the estimation procedure for difference-in-differences.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#DiffinDiffsBase.ExportFormat","page":"Results","title":"DiffinDiffsBase.ExportFormat","text":"ExportFormat\n\nSupertype for all types representing the format for exporting an AbstractDIDResult.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#DiffinDiffsBase.StataPostHDF","page":"Results","title":"DiffinDiffsBase.StataPostHDF","text":"StataPostHDF <: ExportFormat\n\nExport an AbstractDIDResult for Stata module posthdf.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#DiffinDiffsBase.SubDIDResult","page":"Results","title":"DiffinDiffsBase.SubDIDResult","text":"SubDIDResult{TR,P<:AbstractDIDResult,I,TI} <: AbstractDIDResult{TR}\n\nA view into a DID result of type P with indices for all coefficients of type I and indices for treatment coefficients of type TI. See also view(r::AbstractDIDResult, inds).\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#DiffinDiffsBase.TransSubDIDResult","page":"Results","title":"DiffinDiffsBase.TransSubDIDResult","text":"TransSubDIDResult{TR,P,M,I,TI} <: AbstractDIDResult{TR}\n\nEstimation results obtained from a linear transformation of a subset of coefficient estimates from DIDResult. See also TransformedDIDResult, lincom and rescale.\n\nParameters\n\nP: type of the result that is transformed.\nM: type of the matrix representing the linear transformation.\nI: type of indices for all coefficients.\nTI: type of indices for treatment coefficients.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#DiffinDiffsBase.TransformedDIDResult","page":"Results","title":"DiffinDiffsBase.TransformedDIDResult","text":"TransformedDIDResult{TR,P,M} <: AbstractDIDResult{TR}\n\nEstimation results obtained from a linear transformation of all coefficient estimates from DIDResult. See also TransSubDIDResult, lincom and rescale.\n\nParameters\n\nP: type of the result that is transformed.\nM: type of the matrix representing the linear transformation.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#Base.parent-Tuple{AbstractDIDResult}","page":"Results","title":"Base.parent","text":"parent(r::AbstractDIDResult)\n\nReturn the AbstractDIDResult from which r is generated.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#Base.view-Tuple{AbstractDIDResult, Any}","page":"Results","title":"Base.view","text":"view(r::AbstractDIDResult, inds)\n\nReturn a SubDIDResult that lazily references elements from r at the given index or indices inds without constructing a copied subset.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase._treatnames-Tuple{Any}","page":"Results","title":"DiffinDiffsBase._treatnames","text":"_treatnames(treatcells)\n\nGenerate names for treatment coefficients. Assume treatcells is compatible with the Tables.jl interface.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.agg-Tuple{DIDResult}","page":"Results","title":"DiffinDiffsBase.agg","text":"agg(r::DIDResult)\n\nAggregate difference-in-differences estimates and return a subtype of AggregatedDIDResult. The implementation depends on the type of r.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.checktreatindex-Tuple{AbstractVector{<:Real}, Any}","page":"Results","title":"DiffinDiffsBase.checktreatindex","text":"checktreatindex(inds, tinds)\n\nCheck whether all indices for treatment coefficients tinds are positioned before any other index in inds. This is required to be true for methods such as treatcoef and treatvcov to work properly. If the test fails, an ArgumentError exception is thrown.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.coefinds-Tuple{AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.coefinds","text":"coefinds(r::AbstractDIDResult)\n\nReturn the map from coefficient names to integer indices for retrieving estimates by name.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.didspec-Tuple","page":"Results","title":"DiffinDiffsBase.didspec","text":"didspec(args...; kwargs...)\n\nConstruct a StatsSpec for difference-in-differences with the specified arguments.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.getexportformat-Tuple{}","page":"Results","title":"DiffinDiffsBase.getexportformat","text":"getexportformat()\n\nReturn the default ExportFormat for post!.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.lincom","page":"Results","title":"DiffinDiffsBase.lincom","text":"lincom(r::AbstractDIDResult, linmap::AbstractMatrix{<:Real}, subset=nothing)\n\nLinearly transform the coefficient estimates from DID result r through a matrix linmap. The number of columns of linmap must match the total number of coefficients from r. If linmap is not square (with fewer rows than columns), subset must be specified with indices representing coefficients that remain after the transformation. See also rescale.\n\n\n\n\n\n","category":"function"},{"location":"lib/results/#DiffinDiffsBase.ncovariate-Tuple{AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.ncovariate","text":"ncovariate(r::AbstractDIDResult)\n\nReturn the number of covariate coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.ntreatcoef-Tuple{AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.ntreatcoef","text":"ntreatcoef(r::AbstractDIDResult)\n\nReturn the number of treatment coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.outcomename-Tuple{AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.outcomename","text":"outcomename(r::AbstractDIDResult)\n\nReturn the name of outcome variable generated by StatsModels.coefnames. See also responsename.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.parse_didargs!-Tuple{Vector{Any}, Dict{Symbol, Any}}","page":"Results","title":"DiffinDiffsBase.parse_didargs!","text":"parse_didargs!(args::Vector{Any}, kwargs::Dict{Symbol,Any})\n\nReturn a Dict that is suitable for being passed to valid_didargs for further processing.\n\nAny TreatmentTerm or FormulaTerm in args is decomposed. Any collection of terms is converted to TermSet. Keys are assigned to all positional arguments based on their types. An optional name for StatsSpec can be included in args as a string. The order of positional arguments is irrelevant.\n\nThis function is required for @specset to work properly.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.post!-Tuple{Any, Any}","page":"Results","title":"DiffinDiffsBase.post!","text":"post!(f, r; kwargs...)\n\nExport result r in a default ExportFormat.\n\nThe default format can be retrieved via getexportformat and modified via setexportformat!. The keyword arguments that can be accepted depend on the format and the type of r.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.post!-Tuple{Any, StataPostHDF, AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.post!","text":"post!(f, ::StataPostHDF, r::AbstractDIDResult; kwargs...)\n\nExport result r for Stata module posthdf. A subset of field values from r are placed in f by setting key-value pairs, where f can be either an HDF5.Group or any object that can be indexed by strings.\n\nKeywords\n\nmodel::String=repr(typeof(r)): name of the model.\nfields::Union{AbstractVector{<:Union{Symbol, Pair{String,Symbol}}}, Nothing}=nothing: additional fields to be exported; alternative names can be specified with Pairs.\nat::Union{AbstractVector{<:Real}, Bool, Nothing}=nothing: post the at vector in Stata.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.rescale","page":"Results","title":"DiffinDiffsBase.rescale","text":"rescale(r::AbstractDIDResult, scale::AbstractVector{<:Real}, subset=nothing)\nrescale(r::AbstractDIDResult, by::Pair, subset=nothing)\n\nRescale the coefficient estimates from DID result r. The order of elements in scale must match the order of coefficients. If the length of scale is smaller than the total number of coefficient, subset must be specified with indices representing coefficients that remain after the transformation. Alternatively, if by is specified in the same way for apply, the scales can be computed based on values in treatcells(r). In this case, only treatment coefficients are transformed even if subset is not specified. See lincom for more general transformation.\n\n\n\n\n\n","category":"function"},{"location":"lib/results/#DiffinDiffsBase.setexportformat!-Tuple{ExportFormat}","page":"Results","title":"DiffinDiffsBase.setexportformat!","text":"setexportformat!(format::ExportFormat)\n\nSet the default ExportFormat for post!.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.treatcells-Tuple{AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.treatcells","text":"treatcells(r::AbstractDIDResult)\n\nReturn a Tables.jl-compatible tabular description of treatment coefficients in the order of coefnames (without covariates).\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.treatcoef-Tuple{AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.treatcoef","text":"treatcoef(r::AbstractDIDResult)\n\nReturn a view of treatment coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.treatindex-Tuple{Int64, Colon}","page":"Results","title":"DiffinDiffsBase.treatindex","text":"treatindex(ntcoef::Int, I)\n\nExtract indices referencing the treatment coefficients from I based on the total number of treatment coefficients ntcoef.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.treatment-Tuple{AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.treatment","text":"treatment(r::AbstractDIDResult)\n\nReturn the treatment specification.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.treatnames-Tuple{AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.treatnames","text":"treatnames(r::AbstractDIDResult)\n\nReturn a vector of names for treatment coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.treatvcov-Tuple{AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.treatvcov","text":"treatvcov(r::AbstractDIDResult)\n\nReturn a view of variance-covariance matrix for treatment coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.valid_didargs-Tuple{Dict{Symbol, Any}}","page":"Results","title":"DiffinDiffsBase.valid_didargs","text":"valid_didargs(args::Dict{Symbol,Any})\n\nReturn a tuple of objects that can be accepted by the constructor of StatsSpec. If no DiffinDiffsEstimator is found in args, try to select one based on other information.\n\nThis function is required for @specset to work properly.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.vce-Tuple{AbstractDIDResult}","page":"Results","title":"DiffinDiffsBase.vce","text":"vce(r::AbstractDIDResult)\n\nReturn the covariance estimator used to estimate variance-covariance matrix.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.coef-Tuple{AbstractDIDResult, String}","page":"Results","title":"StatsAPI.coef","text":"coef(r::AbstractDIDResult, name::String)\ncoef(r::AbstractDIDResult, name::Symbol)\ncoef(r::AbstractDIDResult, i::Int)\ncoef(r::AbstractDIDResult, inds)\n\nRetrieve a point estimate by name (as in coefnames) or integer index. Return a vector of estimates if an iterable collection of names or integers are specified.\n\nIndexing by name requires the method coefinds(r). See also AbstractDIDResult.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.coef-Tuple{AbstractDIDResult, Vararg{Pair}}","page":"Results","title":"StatsAPI.coef","text":"coef(r::AbstractDIDResult, bys::Pair...)\n\nReturn a vector of point estimates for treatment coefficients selected based on the specified functions that return either true or false.\n\nDepending on the argument(s) accepted by a function f, it is specified with argument bys as either column_index => f or column_indices => f where column_index is either a Symbol or Int for a column in treatcells and column_indices is an iterable collection of such indices for multiple columns. f is applied elementwise to each specified column to obtain a BitVector for selecting coefficients. If multiple Pairs are provided, the results are combined into one BitVector through bit-wise and.\n\nnote: Note\nThis method only selects estimates for treatment coefficients. Covariates are not taken into account.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.coef-Tuple{AbstractDIDResult}","page":"Results","title":"StatsAPI.coef","text":"coef(r::AbstractDIDResult)\n\nReturn the vector of point estimates for all coefficients.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.coefnames-Tuple{AbstractDIDResult}","page":"Results","title":"StatsAPI.coefnames","text":"coefnames(r::AbstractDIDResult)\n\nReturn a vector of coefficient names.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.confint-Tuple{AbstractDIDResult}","page":"Results","title":"StatsAPI.confint","text":"confint(r::AbstractDIDResult; level::Real=0.95)\n\nReturn a confidence interval for each coefficient estimate. The returned object is of type Tuple{Vector{Float64}, Vector{Float64}} where the first vector collects the lower bounds for all intervals and the second one collects the upper bounds.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.dof_residual-Tuple{AbstractDIDResult}","page":"Results","title":"StatsAPI.dof_residual","text":"dof_residual(r::AbstractDIDResult)\n\nReturn the residual degrees of freedom.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.nobs-Tuple{AbstractDIDResult}","page":"Results","title":"StatsAPI.nobs","text":"nobs(r::AbstractDIDResult)\n\nReturn the number of observations (table rows) involved in estimation.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.responsename-Tuple{AbstractDIDResult}","page":"Results","title":"StatsAPI.responsename","text":"responsename(r::AbstractDIDResult)\n\nReturn the name of outcome variable generated by StatsModels.coefnames. This method is an alias of outcomename.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.vcov","page":"Results","title":"StatsAPI.vcov","text":"vcov(r::AbstractDIDResult, name1::Union{String, Symbol}, name2::Union{String, Symbol}=name1)\nvcov(r::AbstractDIDResult, i::Int, j::Int=i)\nvcov(r::AbstractDIDResult, inds)\n\nRetrieve the covariance between two coefficients by name (as in coefnames) or integer index. Return the variance if only one name or index is specified. Return a variance-covariance matrix for selected coefficients if an iterable collection of names or integers are specified.\n\nIndexing by name requires the method coefinds(r). See also AbstractDIDResult.\n\n\n\n\n\n","category":"function"},{"location":"lib/results/#StatsAPI.vcov-Tuple{AbstractDIDResult, Vararg{Pair}}","page":"Results","title":"StatsAPI.vcov","text":"vcov(r::AbstractDIDResult, bys::Pair...)\n\nReturn a variance-covariance matrix for treatment coefficients selected based on the specified functions that return either true or false.\n\nDepending on the argument(s) accepted by a function f, it is specified with argument bys as either column_index => f or column_indices => f where column_index is either a Symbol or Int for a column in treatcells and column_indices is an iterable collection of such indices for multiple columns. f is applied elementwise to each specified column to obtain a BitVector for selecting coefficients. If multiple Pairs are provided, the results are combined into one BitVector through bit-wise and.\n\nnote: Note\nThis method only selects estimates for treatment coefficients. Covariates are not taken into account.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.vcov-Tuple{AbstractDIDResult}","page":"Results","title":"StatsAPI.vcov","text":"vcov(r::AbstractDIDResult)\n\nReturn the variance-covariance matrix for all coefficient estimates.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#StatsAPI.weights-Tuple{AbstractDIDResult}","page":"Results","title":"StatsAPI.weights","text":"weights(r::AbstractDIDResult)\n\nReturn the column name of the weight variable. Return nothing if weights is not specified for estimation.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#DiffinDiffsBase.@did-Tuple","page":"Results","title":"DiffinDiffsBase.@did","text":"@did [option option=val ...] \"name\" args... kwargs...\n\nConduct difference-in-differences estimation with the specified arguments. The order of the arguments is irrelevant.\n\nArguments\n\n[option option=val ...]: optional settings for @did including keyword arguments passed to an instance of StatsSpec.\nname::AbstractString: an optional name for the StatsSpec.\nargs... kwargs...: a list of arguments to be processed by parse_didargs! and valid_didargs.\n\nNotes\n\nWhen expanded outside @specset, a StatsSpec is constructed and then estimated by calling this instance. Options for [StatsSpec] can be provided in a bracket [...] as the first argument after @did with each option separated by white space. For options that take a Boolean value, specifying the name of the option is enough for setting the value to be true. By default, only a result object that is a subtype of DIDResult is returned.\n\nWhen expanded inside @specset, @did informs @specset the methods for processing the arguments. Any option specified in the bracket is ignored.\n\nOptions for the behavior of @did can be provided in a bracket [...] as the first argument with each option separated by white space. For options that take a Boolean value, specifying the name of the option is enough for setting the value to be true.\n\nThe following options are available for altering the behavior of @did:\n\nnoproceed::Bool=false: return the constructed StatsSpec without conducting the procedure.\nverbose::Bool=false: print the name of each step when it is called.\nkeep=nothing: names (of type Symbol) of additional objects to be returned.\nkeepall::Bool=false: return all objects generated by procedures along with arguments from the StatsSpecs.\npause::Int=0: break the iteration over StatsSteps after finishing the specified number of steps (for debugging).\n\n\n\n\n\n","category":"macro"},{"location":"lib/results/#InteractionWeightedDIDs.RegDIDResultOrAgg","page":"Results","title":"InteractionWeightedDIDs.RegDIDResultOrAgg","text":"RegDIDResultOrAgg{TR,Haslsweights}\n\nUnion type of RegressionBasedDIDResult and AggregatedRegDIDResult.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#InteractionWeightedDIDs.AggregatedRegDIDResult","page":"Results","title":"InteractionWeightedDIDs.AggregatedRegDIDResult","text":"AggregatedRegDIDResult{TR,Haslsweights,P<:RegressionBasedDIDResult,I} <: AggregatedDIDResult{TR,P}\n\nEstimation results aggregated from a RegressionBasedDIDResult. See also agg.\n\nFields\n\nparent::P: the RegressionBasedDIDResult from which the results are generated.\ninds::I: indices of the coefficient estimates from parent used to generate the results.\ncoef::Vector{Float64}: coefficient estimates.\nvcov::Matrix{Float64}: variance-covariance matrix for the estimates.\ncoefweights::Matrix{Float64}: coefficient weights used to aggregate the coefficient estimates from parent.\ntreatweights::Vector{Float64}: sum of treatweights from parent over combined treatcells.\ntreatcounts::Vector{Int}: sum of treatcounts from parent over combined treatcells.\ncoefnames::Vector{String}: coefficient names.\ncoefinds::Dict{String, Int}: a map from coefnames to integer indices for retrieving estimates by name.\ntreatcells::VecColumnTable: cells combined from the treatcells from parent.\nlsweights::Union{TableIndexedMatrix, Nothing}: cell-level least-square weights.\ncellymeans::Union{Vector{Float64}, Nothing}: cell-level averages of the outcome variable.\ncellweights::Union{Vector{Float64}, Nothing}: total sample weights for each cell.\ncellcounts::Union{Vector{Int}, Nothing}: number of observations for each cell.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#InteractionWeightedDIDs.ContrastResult","page":"Results","title":"InteractionWeightedDIDs.ContrastResult","text":"ContrastResult{T,M,R,C} <: AbstractMatrix{T}\n\nMatrix type that holds least-square weights obtained from one or more RegDIDResultOrAggs computed over the same set of cells and cell-level averages. See also contrast.\n\nThe least-square weights are stored in a Matrix that can be retrieved with property name :m, where the weights for each treatment coefficient are stored columnwise starting from the second column and the first column contains the cell-level averages of outcome variable. The indices for cells can be accessed with property name :r; and indices for identifying the coefficients can be accessed with property name :c. The RegDIDResultOrAggs used to generate the ContrastResult can be accessed by calling parent.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#InteractionWeightedDIDs.RegressionBasedDIDResult","page":"Results","title":"InteractionWeightedDIDs.RegressionBasedDIDResult","text":"RegressionBasedDIDResult{TR,CohortInteracted,Haslsweights} <: DIDResult{TR}\n\nEstimation results from regression-based difference-in-differences.\n\nFields\n\ncoef::Vector{Float64}: coefficient estimates.\nvcov::Matrix{Float64}: variance-covariance matrix for the estimates.\nvce::CovarianceEstimator: variance-covariance estiamtor.\ntr::TR: treatment specification.\npr::AbstractParallel: parallel trend assumption.\ntreatweights::Vector{Float64}: total sample weights from observations for which the corresponding treatment indicator takes one.\ntreatcounts::Vector{Int}: total number of observations for which the corresponding treatment indicator takes one.\nesample::BitVector: indicator for the rows from data involved in estimation.\nnobs::Int: number of observations involved in estimation.\ndof_residual::Int: residual degree of freedom.\nF::Float64: F-statistic for overall significance of regression model.\np::Float64: p-value corresponding to the F-statistic.\nyname::String: name of the outcome variable.\ncoefnames::Vector{String}: coefficient names.\ncoefinds::Dict{String, Int}: a map from coefnames to integer indices for retrieving estimates by name.\ntreatcells::VecColumnTable: a tabular description of cells where a treatment indicator takes one.\ntreatname::Symbol: column name for the variable representing treatment time.\nyxterms::Dict{AbstractTerm, AbstractTerm}: a map from all specified terms to concrete terms.\nyterm::AbstractTerm: the specified term for outcome variable.\nxterms::Vector{AbstractTerm}: the specified terms for covariates and fixed effects.\ncontrasts::Union{Dict{Symbol, Any}, Nothing}: contrast coding to be processed by StatsModels.jl.\nweightname::Union{Symbol, Nothing}: column name of the sample weight variable.\nfenames::Vector{String}: names of the fixed effects.\nnfeiterations::Union{Int, Nothing}: number of iterations for the fixed effect solver to reach convergence.\nfeconverged::Union{Bool, Nothing}: whether the fixed effect solver has converged.\nnfesingledropped::Int: number of singleton observations for fixed effects that have been dropped.\nlsweights::Union{TableIndexedMatrix, Nothing}: cell-level least-square weights.\ncellymeans::Union{Vector{Float64}, Nothing}: cell-level averages of the outcome variable.\ncellweights::Union{Vector{Float64}, Nothing}: total sample weights for each cell.\ncellcounts::Union{Vector{Int}, Nothing}: number of observations for each cell.\n\n\n\n\n\n","category":"type"},{"location":"lib/results/#DiffinDiffsBase.agg","page":"Results","title":"DiffinDiffsBase.agg","text":"agg(r::RegressionBasedDIDResult{<:DynamicTreatment}, names=nothing; kwargs...)\n\nAggregate coefficient estimates from r by values taken by the columns from r.treatcells indexed by names with weights proportional to treatweights within each relative time.\n\nKeywords\n\nbys=nothing: columnwise transformations over r.treatcells before grouping by names.\nsubset=nothing: subset of treatment coefficients used for aggregation.\n\n\n\n\n\n","category":"function"},{"location":"lib/results/#DiffinDiffsBase.post!","page":"Results","title":"DiffinDiffsBase.post!","text":"post!(gl, gr, gd, ::StataPostHDF, cr::ContrastResult, left::Int=2, right::Int=3; kwargs...)\n\nExport the least-square weights for coefficients indexed by left and right from cr for Stata module posthdf. The contribution of each cell to the difference between two coefficients are computed and also exported. The weights and contributions are stored as coefficient estimates in three groups gl, gr and gd respectively. The groups can be HDF5.Groups or objects that can be indexed by strings.\n\nKeywords\n\nlefttag::String=string(left): name to be used as depvar in Stata after being prefixed by \"l_\" for the coefficient indexed by left.\nrighttag::String=string(right): name to be used as depvar in Stata after being prefixed by \"r_\" for the coefficient indexed by right.\nmodel::String=\"InteractionWeightedDIDs.ContrastResult\": name of the model.\neqnames::Union{AbstractVector, Nothing}=nothing: equation names prefixed to coefficient names in Stata.\ncolnames::Union{AbstractVector, Nothing}=nothing: column names used as coefficient names in Stata.\nat::Union{AbstractVector{<:Real}, Nothing}=nothing: the at vector in Stata.\n\n\n\n\n\n","category":"function"},{"location":"lib/results/#FixedEffectModels.has_fe-Tuple{RegressionBasedDIDResult}","page":"Results","title":"FixedEffectModels.has_fe","text":"has_fe(r::RegressionBasedDIDResult)\n\nTest whether any fixed effect is involved in regression.\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#InteractionWeightedDIDs.contrast-Tuple{Union{AggregatedRegDIDResult{TR, Haslsweights}, RegressionBasedDIDResult{TR, <:Any, Haslsweights}} where {TR, Haslsweights}, Vararg{Union{AggregatedRegDIDResult{TR, Haslsweights}, RegressionBasedDIDResult{TR, <:Any, Haslsweights}} where {TR, Haslsweights}}}","page":"Results","title":"InteractionWeightedDIDs.contrast","text":"contrast(r1::RegDIDResultOrAgg, rs::RegDIDResultOrAgg...; kwargs)\n\nConstruct a ContrastResult by collecting the computed least-square weights from each of the RegDIDResultOrAgg.\n\nKeywords\n\nsubset=nothing: indices for cells to be included (rows in output).\ncoefs=nothing: indices for coefficients from each result to be included (columns in output).\n\n\n\n\n\n","category":"method"},{"location":"lib/results/#InteractionWeightedDIDs.has_lsweights-Union{Tuple{Union{AggregatedRegDIDResult{TR, H}, RegressionBasedDIDResult{TR, <:Any, H}}}, Tuple{H}, Tuple{TR}} where {TR, H}","page":"Results","title":"InteractionWeightedDIDs.has_lsweights","text":"has_lsweights(r::RegDIDResultOrAgg)\n\nTest whether r contains computed least-sqaure weights (r.lsweights!==nothing).\n\n\n\n\n\n","category":"method"},{"location":"lib/ScaledArrays/#ScaledArrays","page":"ScaledArrays","title":"ScaledArrays","text":"","category":"section"},{"location":"lib/ScaledArrays/","page":"ScaledArrays","title":"ScaledArrays","text":"Modules = [DiffinDiffsBase]\nPages = [\"src/ScaledArrays.jl\"]","category":"page"},{"location":"lib/ScaledArrays/#DiffinDiffsBase.ScaledArray","page":"ScaledArrays","title":"DiffinDiffsBase.ScaledArray","text":"ScaledArray{T,R,N,RA,P} <: AbstractArray{T,N}\n\nArray type that stores data as indices of a range.\n\nFields\n\nrefs::RA<:AbstractArray{R,N}: an array of indices.\npool::P<:AbstractRange: a range that covers all possible values stored by the array.\ninvpool::Dict{T,R}: a map from array elements to indices of pool.\n\n\n\n\n\n","category":"type"},{"location":"lib/ScaledArrays/#DiffinDiffsBase.ScaledArray-2","page":"ScaledArrays","title":"DiffinDiffsBase.ScaledArray","text":"ScaledArray(x::AbstractArray, start, step[, stop]; reftype=Int32, usepool=true)\nScaledArray(x::AbstractArray, step; reftype=Int32, start, stop, usepool=true)\n\nConstruct a ScaledArray from x given the step size. If start or stop is not specified, it will be chosen based on the extrema of x.\n\nKeywords\n\nreftype::Type=Int32: the element type of field refs.\nusepool::Bool=true: find extrema of x based on DataAPI.refpool.\n\n\n\n\n\n","category":"type"},{"location":"lib/ScaledArrays/#DiffinDiffsBase.align-Tuple{AbstractArray, Union{ScaledArray{T, R, N, RA, P}, SubArray{<:Any, <:Any, <:ScaledArray{T, R, N, RA, P}}} where {T, R, N, RA, P}}","page":"ScaledArrays","title":"DiffinDiffsBase.align","text":"align(xs::AbstractArray, sa::ScaledArrOrSub)\n\nConvert xs into a ScaledArray with a pool that has the same first element and step size as the pool from sa.\n\n\n\n\n\n","category":"method"},{"location":"lib/ScaledArrays/#DiffinDiffsBase.scale-Tuple{Union{ScaledArray{T, R, N, RA, P}, SubArray{<:Any, <:Any, <:ScaledArray{T, R, N, RA, P}}} where {T, R, N, RA, P}}","page":"ScaledArrays","title":"DiffinDiffsBase.scale","text":"scale(sa::ScaledArrOrSub)\n\nReturn the step size of the pool of sa.\n\n\n\n\n\n","category":"method"},{"location":"lib/inference/#Inference","page":"Inference","title":"Inference","text":"","category":"section"},{"location":"lib/inference/","page":"Inference","title":"Inference","text":"Modules = [Vcov]","category":"page"},{"location":"lib/inference/#Vcov.cluster-Tuple{Vararg{Symbol}}","page":"Inference","title":"Vcov.cluster","text":"cluster(names::Symbol...)\n\nEstimate variance-covariance matrix with a cluster-robust estimator.\n\nArguments\n\nnames::Symbol...: column names of variables that represent the clusters.\n\n\n\n\n\n","category":"method"},{"location":"lib/inference/#Vcov.names-Tuple{Vcov.ClusterCovariance}","page":"Inference","title":"Vcov.names","text":"names(vce::ClusterCovariance)\n\nReturn column names of variables used to form clusters for vce.\n\n\n\n\n\n","category":"method"},{"location":"lib/inference/#Vcov.nclusters-Tuple{Vcov.ClusterCovariance}","page":"Inference","title":"Vcov.nclusters","text":"nclusters(vce::ClusterCovariance)\n\nReturn the number of clusters for each dimension/way of clustering.\n\n\n\n\n\n","category":"method"},{"location":"lib/inference/#Vcov.robust-Tuple{}","page":"Inference","title":"Vcov.robust","text":"robust()\n\nEstimate variance-covariance matrix with a heteroskedasticity-robust estimator.\n\n\n\n\n\n","category":"method"},{"location":"lib/inference/#Vcov.simple-Tuple{}","page":"Inference","title":"Vcov.simple","text":"simple()\n\nEstimate variance-covariance matrix with a simple estimator.\n\n\n\n\n\n","category":"method"},{"location":"lib/parallels/#Parallel-Types","page":"Parallel Types","title":"Parallel Types","text":"","category":"section"},{"location":"lib/parallels/","page":"Parallel Types","title":"Parallel Types","text":"Modules = [DiffinDiffsBase]\nPages = [\"src/parallels.jl\"]","category":"page"},{"location":"lib/parallels/#DiffinDiffsBase.TrendOrUnspecifiedPR","page":"Parallel Types","title":"DiffinDiffsBase.TrendOrUnspecifiedPR","text":"TrendOrUnspecifiedPR{C,S}\n\nUnion type of TrendParallel{C,S} and UnspecifiedParallel{C,S}.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.AbstractParallel","page":"Parallel Types","title":"DiffinDiffsBase.AbstractParallel","text":"AbstractParallel{C<:ParallelCondition, S<:ParallelStrength}\n\nSupertype for all parallel types.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.Approximate","page":"Parallel Types","title":"DiffinDiffsBase.Approximate","text":"Approximate <: ParallelStrength\n\nSupertype for all types assuming some notion of parallel holds approximately.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.CovariateConditional","page":"Parallel Types","title":"DiffinDiffsBase.CovariateConditional","text":"CovariateConditional <: ParallelCondition\n\nSupertype for all types assuming some notion of parallel holds after conditioning on covariates.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.Exact","page":"Parallel Types","title":"DiffinDiffsBase.Exact","text":"Exact <: ParallelStrength\n\nAssume some notion of parallel holds exactly.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.NeverTreatedParallel","page":"Parallel Types","title":"DiffinDiffsBase.NeverTreatedParallel","text":"NeverTreatedParallel{C,S} <: TrendParallel{C,S}\n\nAssume a parallel trends assumption holds between any group that received the treatment during the sample periods and a group that did not receive any treatment in any sample period. See also nevertreated.\n\nFields\n\ne::Tuple{Vararg{ValidTimeType}}: group indices for units that did not receive any treatment.\nc::C: an instance of ParallelCondition.\ns::S: an instance of ParallelStrength.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.NotYetTreatedParallel","page":"Parallel Types","title":"DiffinDiffsBase.NotYetTreatedParallel","text":"NotYetTreatedParallel{C,S} <: TrendParallel{C,S}\n\nAssume a parallel trends assumption holds between any group that received the treatment relatively early and any group that received the treatment relatively late (or never receved). See also notyettreated.\n\nFields\n\ne::Tuple{Vararg{ValidTimeType}}: group indices for units that received the treatment relatively late.\necut::Tuple{Vararg{ValidTimeType}}: user-specified period(s) when units in a group in e started to receive treatment or show anticipation effects.\nc::C: an instance of ParallelCondition.\ns::S: an instance of ParallelStrength.\n\nnote: Note\necut could be different from minimum(e) ifnever-treated groups are included and use indices with smaller values;\nthe sample has a rotating panel structure with periods overlapping with some others.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.ParallelCondition","page":"Parallel Types","title":"DiffinDiffsBase.ParallelCondition","text":"ParallelCondition\n\nSupertype for all types imposing conditions of parallel.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.ParallelStrength","page":"Parallel Types","title":"DiffinDiffsBase.ParallelStrength","text":"ParallelStrength\n\nSupertype for all types specifying the strength of parallel.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.TrendParallel","page":"Parallel Types","title":"DiffinDiffsBase.TrendParallel","text":"TrendParallel{C,S} <: AbstractParallel{C,S}\n\nSupertype for all parallel types that assume a parallel trends assumption holds over all the relevant time periods.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.Unconditional","page":"Parallel Types","title":"DiffinDiffsBase.Unconditional","text":"Unconditional <: ParallelCondition\n\nAssume some notion of parallel holds without conditions.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.UnspecifiedParallel","page":"Parallel Types","title":"DiffinDiffsBase.UnspecifiedParallel","text":"UnspecifiedParallel{C,S} <: AbstractParallel{C,S}\n\nA parallel trends assumption (PTA) without explicitly specified relations across treatment groups. See also unspecifiedpr.\n\nWith this parallel type, operations for complying with a PTA are suppressed. This is useful, for example, when the user-provided regressors and sample restrictions need to be accepted without any PTA-specific alteration.\n\nFields\n\nc::C: an instance of ParallelCondition.\ns::S: an instance of ParallelStrength.\n\n\n\n\n\n","category":"type"},{"location":"lib/parallels/#DiffinDiffsBase.exact-Tuple{}","page":"Parallel Types","title":"DiffinDiffsBase.exact","text":"exact()\n\nAlias for Exact().\n\n\n\n\n\n","category":"method"},{"location":"lib/parallels/#DiffinDiffsBase.istreated","page":"Parallel Types","title":"DiffinDiffsBase.istreated","text":"istreated(pr::TrendParallel, x)\n\nTest whether x represents the treatment time for a group of units that are not treated. See also istreated!.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallels/#DiffinDiffsBase.istreated!","page":"Parallel Types","title":"DiffinDiffsBase.istreated!","text":"istreated!(out::AbstractVector{Bool}, pr::TrendParallel, x::AbstractArray)\n\nFor each element in x, test whether it represents the treatment time for a group of units that are not treated and save the result in out. See also istreated.\n\n\n\n\n\n","category":"function"},{"location":"lib/parallels/#DiffinDiffsBase.nevertreated-Tuple{Any, ParallelCondition, ParallelStrength}","page":"Parallel Types","title":"DiffinDiffsBase.nevertreated","text":"nevertreated(e, c::ParallelCondition, s::ParallelStrength)\nnevertreated(e; c=Unconditional(), s=Exact())\n\nConstruct a NeverTreatedParallel with fields set by the arguments. By default, c is set as Unconditional() and s is set as Exact(). When working with @formula, a wrapper method of nevertreated calls this method.\n\nExamples\n\njulia> nevertreated(-1)\nParallel trends with any never-treated group:\n  Never-treated groups: -1\n\njulia> typeof(nevertreated(-1))\nNeverTreatedParallel{Unconditional,Exact}\n\njulia> nevertreated([-1, 0])\nParallel trends with any never-treated group:\n  Never-treated groups: -1, 0\n\njulia> nevertreated([-1, 0]) == nevertreated(-1:0) == nevertreated(Set([-1, 0]))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"lib/parallels/#DiffinDiffsBase.nevertreated-Tuple{Vararg{AbstractTerm}}","page":"Parallel Types","title":"DiffinDiffsBase.nevertreated","text":"nevertreated(ts::AbstractTerm...)\n\nA wrapper method of nevertreated for working with @formula.\n\n\n\n\n\n","category":"method"},{"location":"lib/parallels/#DiffinDiffsBase.notyettreated-Tuple{Any, Any, ParallelCondition, ParallelStrength}","page":"Parallel Types","title":"DiffinDiffsBase.notyettreated","text":"notyettreated(e, ecut, c::ParallelCondition, s::ParallelStrength)\nnotyettreated(e, ecut=e; c=Unconditional(), s=Exact())\n\nConstruct a NotYetTreatedParallel with fields set by the arguments. By default, c is set as Unconditional() and s is set as Exact(). When working with @formula, a wrapper method of notyettreated calls this method.\n\nExamples\n\njulia> notyettreated(5)\nParallel trends with any not-yet-treated group:\n  Not-yet-treated groups: 5\n  Treated since: 5\n\njulia> typeof(notyettreated(5))\nNotYetTreatedParallel{Unconditional,Exact}\n\njulia> notyettreated([-1, 5, 6], 5)\nParallel trends with any not-yet-treated group:\n  Not-yet-treated groups: -1, 5, 6\n  Treated since: 5\n\njulia> notyettreated([4, 5, 6], [4, 5, 6])\nParallel trends with any not-yet-treated group:\n  Not-yet-treated groups: 4, 5, 6\n  Treated since: 4, 5, 6\n\n\n\n\n\n","category":"method"},{"location":"lib/parallels/#DiffinDiffsBase.notyettreated-Tuple{Vararg{AbstractTerm}}","page":"Parallel Types","title":"DiffinDiffsBase.notyettreated","text":"notyettreated(ts::AbstractTerm...)\n\nA wrapper method of notyettreated for working with @formula.\n\n\n\n\n\n","category":"method"},{"location":"lib/parallels/#DiffinDiffsBase.unconditional-Tuple{}","page":"Parallel Types","title":"DiffinDiffsBase.unconditional","text":"unconditional()\n\nAlias for Unconditional().\n\n\n\n\n\n","category":"method"},{"location":"lib/parallels/#DiffinDiffsBase.unspecifiedpr","page":"Parallel Types","title":"DiffinDiffsBase.unspecifiedpr","text":"unspecifiedpr(c::ParallelCondition=Unconditional(), s::ParallelStrength=Exact())\n\nConstruct an UnspecifiedParallel with fields set by the arguments. This is an alias of the inner constructor of UnspecifiedParallel.\n\n\n\n\n\n","category":"function"},{"location":"#DiffinDiffs.jl","page":"Home","title":"DiffinDiffs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation site for DiffinDiffs.jl!","category":"page"},{"location":"","page":"Home","title":"Home","text":"DiffinDiffs.jl is a suite of Julia packages for difference-in-differences (DID). The goal of its development is to promote applications of the latest advances in econometric methodology related to DID in academic research while leveraging the performance and composability of the Julia language.","category":"page"},{"location":"#Why-DiffinDiffs.jl?","page":"Home","title":"Why DiffinDiffs.jl?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fast: Handle datasets of multiple gigabytes with ease\nTransparent: Completely open source and natively written in Julia\nExtensible: Unified interface with modular package organization","category":"page"},{"location":"#Package-Organization","page":"Home","title":"Package Organization","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiffinDiffs.jl reexports types, functions and macros defined in component packages that are separately registered. The package itself does not host any concrete functionality except documentation. This facilitates decentralized code development under a unified framework.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Package Description Version Status\nDiffinDiffsBase Base package for DiffinDiffs.jl (Image: version) (Image: pkgeval)\nInteractionWeightedDIDs Regression-based multi-period DID (Image: version) (Image: pkgeval)","category":"page"},{"location":"","page":"Home","title":"Home","text":"More components will be included in the future as development moves forward.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DiffinDiffs.jl can be installed with the Julia package manager Pkg. From the Julia REPL, type ] to enter the Pkg REPL and run:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add DiffinDiffs","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install all the component packages of DiffinDiffs.jl as dependencies. There is no need to explicitly add the individual components unless one needs to access internal objects.","category":"page"}]
}
