"""
    @fieldequal Supertype

Define a method of `==` for all subtypes of `Supertype`
such that `==` returns true if two instances have the same field values.
"""
macro fieldequal(Supertype)
    return esc(quote
        function ==(x::T, y::T) where T <: $Supertype
            f = fieldnames(T)
            getfield.(Ref(x),f) == getfield.(Ref(y),f)
        end
    end)
end

"""
    cb(args...)

Construct a vector from `ConstantTerm`s provided as arguments.
This method is useful for working with `@formula`.

Note that `@formula` does not accept function calls with empty argument.
Hence, `cb()` cannot be used to create an empty vector `[]`
in the expression passed to `@formula`.
However, passing `cb` (without the parenthesis) to `@formula` will return `[]`
due to [`unpack`](@ref).
"""
cb(args...) = [arg isa ConstantTerm ? arg.n :
    throw(ArgumentError("only `ConstantTerm`s are accepted.")) for arg in args]

cb() = []

"""
    unpack(t::ConstantTerm)

Return the value represented by `t`.
"""
unpack(t::ConstantTerm) = t.n

"""
    unpack(t::Term)

If `t.sym` is the name of an object defined in `Main`,
either call its method with no argument if it exists
or return the object itself.
Otherwise, return `t.sym`.
"""
function unpack(t::Term)
    if isdefined(Main, t.sym)
        f = getfield(Main,  t.sym)
        hasmethod(f, Tuple{}) ? f() : f
    else
        return t.sym
    end
end

"""
    unpack(t::FunctionTerm{F})

Call the function represented by `t`.
"""
unpack(t::FunctionTerm{F}) where F = F.instance(t.args_parsed...)

"""
    kwarg(v)

Return a key-value `Pair` with the key being a keyword argument name
and the value being `v`.
The key is determined by the type of `v`.
"""
kwarg(::Any) = nothing

"""
    @unpack functionname

Define a method of `functionname` that accepts terms generated by `@formula`
as arguments.
This method can be used to translate terms into
arguments that match the other methods of `functionname`.
Each term is processed by [`unpack`](@ref) and [`kwarg`](@ref).
"""
macro unpack(functionname)
    return esc(quote
        function $functionname(ts::AbstractTerm...)
            args, kwargs = [], []
            for t in ts
                v = unpack(t)
                kv = kwarg(v)
                kv isa Nothing ? push!(args, v) : push!(kwargs, kv)
            end
            return $functionname(args...; kwargs...)
        end
    end)
end

"""
    _args_kwargs(exprs)

Return an expression of `Vector{Any}` and an expression of `Dict{Symbol,Any}`
where the latter collect any `Expr` in `exprs` with `head` being `:(=)`
and the former collects the rest.
This function is useful for preparing arguments for [`parse_didargs!`](@ref)
inside a macro such as [`@did`](@ref).
"""
function _args_kwargs(exprs)
    args = :(Any[])
    kwargs = :(Dict{Symbol,Any}())
    for expr in exprs
        if expr isa Expr && expr.head==:(=)
            key = Expr(:quote, expr.args[1])
            push!(kwargs.args, Expr(:call, :(=>), key, expr.args[2]))
        else
            push!(args.args, expr)
        end
    end
    return args, kwargs
end

"""
    ≊(x::NamedTuple, y::NamedTuple)

Test whether two instances of `NamedTuple` contain
the same set of key-value pairs while ignoring the order.

See https://discourse.julialang.org/t/check-equality-of-two-namedtuples-with-order-of-the-fields-ignored
"""
≊(x::NamedTuple{N1,T1}, y::NamedTuple{N2,T2}) where {N1,T1,N2,T2} =
    length(N1) === length(union(N1,N2)) &&
        all(k->getfield(x,k)==getfield(y,k), keys(x))

"""
    exampledata()

Return the names of available example datasets.
"""
exampledata() = (:hrs, :nsw, :mpdta)

"""
    exampledata(name::Union{Symbol,String})

Return a `CSV.File` containing the example dataset with the specified `name`.
"""
function exampledata(name::Union{Symbol,String})
    Symbol(name) in exampledata() ||
        throw(ArgumentError("example dataset $(name) does not exist"))
    path = (@__DIR__)*"/../data/$(name).csv.gz"
    cols = open(path) |> GzipDecompressorStream |> read |> CSV.File |> VecColumnTable
    # Avoid customized index type for columns from CSV.File
    for i in 1:ncol(cols)
        col = _columns(cols)[i]
        _columns(cols)[i] = convert(Vector, col)
    end
    return cols
end

# Check whether the input data is a column table
function checktable(data)
    istable(data) ||
        throw(ArgumentError("data of type $(typeof(data)) is not Tables.jl-compatible"))
    Tables.columnaccess(data) ||
        throw(ArgumentError("data of type $(typeof(data)) is not a column table"))
end
