"""
    @fieldequal Supertype

Define a method of `==` for all subtypes of `Supertype`
such that `==` returns true if two instances have the same field values.
"""
macro fieldequal(Supertype)
    return esc(quote
        function ==(x::T, y::T) where T <: $Supertype
            f = fieldnames(T)
            getfield.(Ref(x),f) == getfield.(Ref(y),f)
        end
    end)
end

"""
    cb(args...)

Construct a vector from `ConstantTerm`s provided as arguments.
This method is useful for working with `@formula`.

Note that `@formula` does not accept function calls with empty argument.
Hence, `cb()` cannot be used to create an empty vector `[]`
in the expression passed to `@formula`.
However, passing `cb` (without the parenthesis) to `@formula` will return `[]`
due to [`unpack`](@ref).
"""
cb(args...) = [arg isa ConstantTerm ? arg.n :
    throw(ArgumentError("only `ConstantTerm`s are accepted.")) for arg in args]

cb() = []

"""
    unpack(t::ConstantTerm)

Return the value represented by `t`.
"""
unpack(t::ConstantTerm) = t.n

"""
    unpack(t::Term)

If `t.sym` is the name of an object defined in `Main`,
either call its method with no argument if it exists
or return the object itself.
Otherwise, return `t.sym`.
"""
function unpack(t::Term)
    if isdefined(Main, t.sym)
        f = getfield(Main,  t.sym)
        hasmethod(f, Tuple{}) ? f() : f
    else
        return t.sym
    end
end

"""
    unpack(t::FunctionTerm{F})

Call the function represented by `t`.
"""
unpack(t::FunctionTerm{F}) where F = F.instance(t.args_parsed...)

"""
    kwarg(v)

Return a key-value `Pair` with the key being a keyword argument name
and the value being `v`.
The key is determined by the type of `v`.
"""
kwarg(::Any) = nothing

"""
    @unpack functionname

Define a method of `functionname` that accepts terms generated by `@formula`
as arguments.
This method can be used to translate terms into
arguments that match the other methods of `functionname`.
Each term is processed by [`unpack`](@ref) and [`kwarg`](@ref).
"""
macro unpack(functionname)
    return esc(quote
        function $functionname(ts::AbstractTerm...)
            args, kwargs = [], []
            for t in ts
                v = unpack(t)
                kv = kwarg(v)
                kv isa Nothing ? push!(args, v) : push!(kwargs, kv)
            end
            return $functionname(args...; kwargs...)
        end
    end)
end

"""
    _args_kwargs(exprs)

Return an expression of `Vector{Any}` and an expression of `Dict{Symbol,Any}`
where the latter collect any `Expr` in `exprs` with `head` being `:(=)`
and the former collects the rest.
This function is useful for preparing arguments for [`parse_didargs!`](@ref)
inside a macro such as [`@did`](@ref).
"""
function _args_kwargs(exprs)
    args = :(Any[])
    kwargs = :(Dict{Symbol,Any}())
    for expr in exprs
        if expr isa Expr && expr.head==:(=)
            key = Expr(:quote, expr.args[1])
            push!(kwargs.args, Expr(:call, :(=>), key, expr.args[2]))
        else
            push!(args.args, expr)
        end
    end
    return args, kwargs
end

"""
    ≊(x::NamedTuple, y::NamedTuple)

Test whether two instances of `NamedTuple` contain
the same set of key-value pairs while ignoring the order.

See https://discourse.julialang.org/t/check-equality-of-two-namedtuples-with-order-of-the-fields-ignored
"""
≊(x::NamedTuple{N1,T1}, y::NamedTuple{N2,T2}) where {N1,T1,N2,T2} =
    length(N1) === length(union(N1,N2)) &&
        all(k->getfield(x,k)==getfield(y,k), keys(x))

"""
    exampledata()

Return the names of available example datasets.
"""
exampledata() = (:hrs, :nsw, :mpdta)

"""
    exampledata(name::Union{Symbol,String})

Return a `CSV.File` containing the example dataset with the specified `name`.
"""
function exampledata(name::Union{Symbol,String})
    Symbol(name) in exampledata() ||
        throw(ArgumentError("example dataset $(name) does not exist"))
    path = (@__DIR__)*"/../data/$(name).csv.gz"
    return open(path) |> GzipDecompressorStream |> read |> CSV.File
end

"""
    RotatingTimeValue{R, T}

A wrapper around a time value for distinguishing potentially different
rotation group it could belong to in a rotating sampling design.
See also [`rotatingtime`](@ref) and [`settime`](@ref).

# Fields
- `rotation::R`: a rotation group in a rotating sampling design.
- `time::T`: a time value belonged to the rotation group.
"""
struct RotatingTimeValue{R, T}
    rotation::R
    time::T
end

"""
    rotatingtime(rotation, time)

Construct [`RotatingTimeValue`](@ref)s from `rotation` and `time`.
This method simply broadcasts the default constructor over the arguments.
"""
rotatingtime(rotation, time) = RotatingTimeValue.(rotation, time)

+(x::RotatingTimeValue, y) = RotatingTimeValue(x.rotation, x.time + y)
+(x, y::RotatingTimeValue) = RotatingTimeValue(y.rotation, x + y.time)
-(x::RotatingTimeValue, y) = RotatingTimeValue(x.rotation, x.time - y)
-(x, y::RotatingTimeValue) = RotatingTimeValue(y.rotation, x - y.time)
*(x::RotatingTimeValue, y) = RotatingTimeValue(x.rotation, x.time * y)
*(x, y::RotatingTimeValue) = RotatingTimeValue(y.rotation, x * y.time)

function -(x::RotatingTimeValue, y::RotatingTimeValue)
    rx = x.rotation
    ry = y.rotation
    rx == ry || throw(ArgumentError("x has rotation $rx while y has rotation $ry"))
    return x.time - y.time
end

function isless(x::RotatingTimeValue, y::RotatingTimeValue)
    rx = x.rotation
    ry = y.rotation
    return isequal(rx, ry) ? isless(x.time, y.time) : isless(rx, ry)
end

==(x::RotatingTimeValue, y::RotatingTimeValue) =
    x.rotation == y.rotation && x.time == y.time

Base.checkindex(::Type{Bool}, inds::AbstractUnitRange, i::RotatingTimeValue) =
    checkindex(Bool, inds, i.time)

@propagate_inbounds getindex(X::AbstractArray, i::RotatingTimeValue) = getindex(X, i.time)

show(io::IO, x::RotatingTimeValue) = print(io, x.rotation, "_", x.time)
function show(io::IO, ::MIME"text/plain", x::RotatingTimeValue)
    println(io, typeof(x), ':')
    println(io, "  rotation: ", x.rotation)
    print(io, "  time:     ", x.time)
end

const ValidTimeType = Union{Signed, TimeType, Period, RotatingTimeValue}

# Check whether the input data is a column table
function checktable(data)
    istable(data) ||
        throw(ArgumentError("data of type $(typeof(data)) is not Tables.jl-compatible"))
    Tables.columnaccess(data) && Tables.columns(data) === data ||
        throw(ArgumentError("data of type $(typeof(data)) is not a column table"))
end
